%%
% Author: N S Narayanaswamy and Anju Srinivasan Zabil
%%


%\documentclass{../../lib/llncs}
\documentclass{llncs}

\usepackage{fullpage}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{comment}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{natbib}

% for Natbib
%\bibpunct{(}{)}{;}{a}{,}{,}

\def\Remark{\noindent{\bf Remark:~}}
\long\def\denspar #1\densend {#1}
\def\DEF{\stackrel{\rm def}{=}}

%%% string defs
\def\cA{{\cal A}}
\def\cB{{\cal B}}
\def\cC{{\cal C}}
\def\cD{{\cal D}}
\def\cE{{\cal E}}
\def\cF{{\cal F}}
\def\cG{{\cal G}}
\def\cH{{\cal H}}
\def\cI{{\cal I}}
\def\cJ{{\cal J}}
\def\cK{{\cal K}}
\def\cL{{\cal L}}
\def\cM{{\cal M}}
\def\cN{{\cal N}}
\def\cO{{\cal O}}
\def\cP{{\cal P}}
\def\cQ{{\cal Q}}
\def\cR{{\cal R}}
\def\cS{{\cal S}}
\def\cT{{\cal T}}
\def\cU{{\cal U}}
\def\cV{{\cal V}}
\def\cW{{\cal W}}
\def\cX{{\cal X}}
\def\cY{{\cal Y}}
\def\cZ{{\cal Z}}
\def\hA{{\hat A}}
\def\hB{{\hat B}}
\def\hC{{\hat C}}
\def\hD{{\hat D}}
\def\hE{{\hat E}}
\def\hF{{\hat F}}
\def\hG{{\hat G}}
\def\hH{{\hat H}}
\def\hI{{\hat I}}
\def\hJ{{\hat J}}
\def\hK{{\hat K}}
\def\hL{{\hat L}}
\def\hP{{\hat P}}
\def\hQ{{\hat Q}}
\def\hR{{\hat R}}
\def\hS{{\hat S}}
\def\hT{{\hat T}}
\def\hX{{\hat X}}
\def\hY{{\hat Y}}
\def\hZ{{\hat Z}}
\def\eps{\epsilon}
\def\C{{\mathcal C}}
\def\F{{\mathcal F}}
\def\A{{\mathcal A}}
\def\hd{\hat{\delta}}
\def\Lr{\Leftrightarrow}
\def\If{{\bf if }}
\def\Then{{\bf then }}
\def\Else{{\bf else }}
\def\Do{{\bf do }}
\def\While{{\bf while }}
\def\Continue{{\bf continue }}
\def\Repeat{{\bf repeat }}
\def\Until{{\bf until }}
\def\eqdef{\stackrel {\triangle}{=}}
\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}


%%% new/renew commands
\renewcommand{\algorithmiccomment}[1]{// #1 } % comment in algorithmic
\newtheorem{observation}{Observation}
\newcommand{\Eqr}[1]{Eq.~(\ref{#1})}
\newcommand{\diff}{\ne}
\newcommand{\OO}[1]{O\left( #1\right)}
\newcommand{\OM}[1]{\Omega\left( #1 \right)}
\newcommand{\Prob}[1]{\Pr\left\{ #1 \right\}}
\newcommand{\Set}[1]{\left\{ #1 \right\}}
\newcommand{\Seq}[1]{\left\langle #1 \right\rangle}
\newcommand{\Range}[1]{\left\{1,\ldots, #1 \right\}}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ignore}[1]{}
\newcommand{\eq}{\equiv}
\newcommand{\abs}[1]{\left| #1\right|}
\newcommand{\set}[1]{\left\{ #1\right\}}
\newcommand{\itoj}{{i \rightarrow j}}
\newcommand{\view}{\mbox{$COMM$}}
\newcommand{\pview}{\mbox{$PView$}}
\newcommand{\vx}{\mbox{${\vec x}$}}
\newcommand{\vy}{\mbox{${\vec y}$}}
\newcommand{\vv}{\mbox{${\vec v}$}}
\newcommand{\vw}{\mbox{${\vec w}$}}
\newcommand{\vb}{\mbox{${\vec b}$}}
\newcommand{\basic}{\mbox{\sc Basic}}
\newcommand{\WR}{\mbox{$\lfloor wr \rfloor$}}
\newcommand{\guarantee}{\mbox{\sc BoundedDT}}
\newcommand{\sq}{{\Delta}}
\newcommand{\Smin}{{S_{0}}}
\newcommand{\outt}{{D^{^+}}}
\newcommand{\outtp}{{\overline{D^{^+}}}}
\newcommand{\inn}{{D^{^-}}}
\newcommand{\innp}{{\overline{D^{^-}}}}
\newcommand{\indexx}{{\gamma}}
\newcommand{\D}{{D}}
\newenvironment{denselist}{
  \begin{list}{(\arabic{enumi})}{\usecounter{enumi}
      \setlength{\topsep}{0pt} \setlength{\partopsep}{0pt}
      \setlength{\itemsep}{0pt} }}{\end{list}}
\newenvironment{denseitemize}{
  \begin{list}{$\bullet$}{ \setlength{\topsep}{0pt}
      \setlength{\partopsep}{0pt} \setlength{\itemsep}{0pt}
    }}{\end{list}}
\newenvironment{subdenselist}{
  \begin{list}{(\arabic{enumi}.\arabic{enumii})}{ \usecounter{enumii}
      \setlength{\topsep}{0pt} \setlength{\partopsep}{0pt}
      \setlength{\itemsep}{0pt} }}{\end{list}}


% D O C U M E N T
\begin{document}
\title{Tree Path Assignments to Sets-A Generalization of the Consecutive Ones Property}

\author{N.S. Narayanaswamy \inst{1} \and Anju Srinivasan Zabil \inst{2}}

\institute{ %The Institute of Mathematical Sciences, Chennai,
  % \email{arvind@imsc.res.in} \and
  Indian Institute of Technology
  Madras, Chennai, \email{swamy@cse.iitm.ernet.in},\\
  Indian Institute of Technology Madras, Chennai,
  \email{anjuzabil@gmail.com}}


\date{}

\maketitle

\begin{abstract}
We consider the following constraint satisfaction problem: Given a set $\cF$ of subsets  of a finite set $U$ of cardinality $n$, a tree $T$ on $n$ vertices, and an assignment of paths from $T$ to each of the subsets, does there exist a bijection $f:U \rightarrow \{v_1,\ldots,v_n\}$ such that for each element of $\cF$,  its image under $f$ is same as the path assigned to it?    A path assignment to a given set of subsets is called {\em feasible} if there exists such a bijection.   In this paper, we characterize feasible path assignments to  a given set of subsets and a tree.   This result is a natural generalization of results on matrices with the Consecutive Ones Property(COP) which can be viewed as a special instance of the problem in which the given tree is a path on $n$ vertices.  We also present a characterization of set systems and trees which have a feasible path assignment.  We also show that testing for a feasible path assignment is isomorphism-complete.  On the other hand, it is known that if the given tree is a path a feasible assignment can be found in polynomial time, and we observe that it can actually be done in logspace.
\end{abstract}

\section{Introduction}
%\subsection{Previous Work}

\noindent
Consecutive ones property (COP) of binary matrices is a widely studied
combinatorial problem. The problem is to rearrange rows(columns) of a
binary matrix in such a way that every column(rows) has its $1$s occur
consecutively. If this is possible the matrix is said to have COP.  It
has several practical applications in diverse fields including
scheduling\cite{hl06}, information retrieval\cite{k77} and computational biology\cite{abh98}. 
Further, it is a tool in graph theory\cite{mcg04} for  interval graph recognition, characterization of hamiltonian graphs, and in integer linear
programming\cite{ht02,hl06}. 
Recognition of COP is polynomial time
solvable by several algorithms. PQ trees\cite{bl76}, variations of PQ
trees\cite{mm09,wlh01,wlh02,mcc04}, ICPIA\cite{nsnrs09} are the main
ones. 
\noindent
The problem of COP can be easily seen as a 
simple constraint satisfaction problem involving a system of sets from
a universe. Every column of the binary matrix can be converted into a
set of integers which are the indices of the rows with $1$s in that
column. When observed in this context, if the matrix has COP, a
reordering of its rows will result in sets that have only consecutive
integers. In other words, the sets are intervals. Indeed the
problem now becomes finding interval assignments to the given set
system \cite{nsnrs09} with a single permutation of the universe (set
of row
indices) permutes each set to its interval. The  result in \cite{nsnrs09} characterize interval assignments
to the sets which can be obtained from a single permutation of the rows.  They show that 
for each set, the interval cardinality assigned to it must be same as the cardinality of the set, and the
intersection cardinality of any two sets must be same as the interesction cardinality of the corresponding intervals.
While this is naturally a necessary condition, it is shown that it is indeed sufficient.  Such an interval assignment
is called an Intersection Cardinality Preserving Interval Assignment (ICPIA).  The idea of decomposing a given 0-1
matrix into prime matrices is then taken from \cite{wlh02} to test if an ICPIA exists for a given set system.  

\noindent
{\bf Our Work:}
A natural generalization of the interval assignment problem is
feasible tree path assignments to a set system which is the topic of
this paper. The problem is defined as follows - given a set system $\cF$
from a universe $U$ and a tree $T$, does  there exist a bijection from the
$U$ to the vertices of $T$ such that each set in the system maps to a
path in $T$.  We refer to this as the Tree Path Assignment problem for an input $(\cF,T)$ pair.As a special case if $T$ is a path the problem becomes
the interval assignment problem.  We focus on the question of generalizing the notion
of an ICPIA \cite{nsnrs09} to characterize feasible path assignments.  We show that
for a given set system, a tree T, and an assignment of paths from $T$ to the sets, there is a bijection
between $U$ and $V(T)$ if and only if all intersection cardinalities among any 3 sets (not necessarily distinct) is same as the intersection cardinality of the paths assigned to them.  This
characterization is proved constructively and it gives a natural data structure that stores all the relevant
bijections between $U$ and $V(T)$.  Further, it also gives an efficient algorithm to test if a path assignment to the
sets is feasible.  This also naturally generalizes the result in \cite{nsnrs09}.  
 
\noindent
It is an interesting fact that for a matrix with the COP, the intersection graph of the corresponding set system is
an interval graph.  A similar connection to a subclass of chordal graphs, and this subclass contains interval graphs, exists for the generalization of COP.  In this case, the intersection graph of the corresponding set system must be a
{\em path chordal} graph. Chordal
graphs are of great significance, extensively studied, and have several applications.
 One of
the well known and interesting properties of a chordal graphs is its
connection with intersection graphs\cite{mcg04}. For every chordal
graph, there exists a tree and a family of subtrees of this tree such
that the intersection graph of this family is isomorphic to the
chordal graph\cite{plr70,gav78,bp93}.  Certain format of these trees are called clique
trees\cite{apy92} of the graph which is a compact representation of the
chordal graph. There has also been work done on the generalization of
clique trees to clique hypergraphs\cite{km02}.  If the chordal graph can be represented as
the intersection graph of paths in a tree, then the graph is called  path graph\cite{mcg04} or path
chordal graph.  Therefore, it is clear that if there is a bijection from $U$ to $V(T)$ such that
the sets map to paths, then the intersection graph of the set system is indeed a path chordal graph.
This is, however, only a necessary condition and can be checked efficiently, as  path graph recognition is polynomial
solvable\cite{gav78,aas93}.  Indeed, it is possible to construct a set system and tree, such that
the intersection graph is a path chordal graph, but there is no bijection between $U$ and $V(T)$ such that
the sets map to paths.   This connection indeed suggests that our problem is indeed as hard as path graph 
isomorphism.   Further path graph isomorphism is known be isomorphism-complete, see for example \cite{kklv10}.  In the second part of this paper, we decompose our search for a bijection between $U$ and $V(T)$ into subproblems.  Each subproblem is on a set system in which for each set, there is another set in the set system with which the intersection is {\em strict}- there is a non-empty intersection, but neither is contained in the other.  This is in the spirit of results in \cite{wlh02,nsnrs09} where to test for COP in a given matrix, the COP problem is solved on an equivalent set of prime matrices.  Our decomposition localizes the challenge of path graph isomorphism to two problems.  

Finally, we show that Tree Path Assignment is isomorphism-complete.  We also point out Consecutive Ones Testing is in Logspace from two different results in the literature \cite{kklv10, mcc04}. To the best of our knowledge this observation has not been made earlier.  

\noindent
{\bf Roadmap:} In Section \ref{prelims} we present the necessary preliminaries, in Section \ref{feasible} we present our characterization of feasible tree path assignments, and in Section \ref{decompos} we present the characterizing subproblems for finding a bijection between $U$ and $V(T)$ such that sets map to tree paths. Finally, in Section \ref{complexity} we conclude by showing that Tree Path Assignment is GI-Complete, and also observe that Consecutive Ones Testing is in Logspace.  
% \noindent
% It has been long known that interval graph recognition is in
% logspace\cite{rei84}. Recently interval graph isomorphism was also
% shown to be logspace decidable using a logspace canonization algorithm
% by \cite{kklv10}. 
% This result is built on top of logspace results of
% undirected graph connectivity \cite{rei08}, logspace tractability
% using a certain logical formalism called FP+C and modular
% decomposition of interval graphs\cite{lau10} etc.
% Interval graphs are closely connected to binary matrices with COP. The
% maximal clique vertex incidence matrix (matrix with rows representing
% maximal cliques and columns representing vertices of a graph) has COP
% on columns iff the graph is an interval graph\cite{fg65}. This follows
% from the interval graph characterization by \cite{gh64}. Due to this
% close relation it is natural to see if consecutive ones property can be
% tested in logspace. \\
% \noindent
% We also explore some extensions of the interval assignment problem in
% \cite{nsnrs09}, namely caterpillar path assignment problem.

% We present a logspace algorithm here that uses the
% ICPIA characterization of binary matrices with COP (set system
% associated with such a matrix)\cite{nsnrs09}.


% \section{Preliminaries}
% A {\em hypergraph} $\cH=(V,E)$  has vertex set $V=\{x_1,x_2, \dots x_n\}$
% and edge set $E \subseteq V$.

% \noindent
% The collection $\F = \{S_i \mid S_i \subseteq U, S_i \ne \O, i \in
% I\}$ is a {\em set system} of a universe $U$.

% \noindent
% Consider a {\em binary matrix} $M$ of order $n \times m$.  The set
% sysetm corresponding to the binary matrix is $\cF_M = \{S_i \mid S_i
% \subseteq U, i \in [m]\}$ where $U = \{x_i \mid i \in [n]\}$ such that
% $x_j \in S_i$ iff $M_{ij} = 1$.

\section{Preliminaries} \label{prelims}
In this paper, the collection $\F = \{S_i \mid S_i \subseteq U, S_i
\ne \O, i \in I\}$ is a {\em set system} of universe, $U = \{1,
\ldots, n\}$. Moreoever, a set system is assumed to ``cover'' the universe,
i.e. $ \bigcup_{i \in I}S_i = U$. \\

\noindent
The graph $T=(V,E)$ represents a given tree with $|V| = n$. Further,
for simplicity, $V$ is defined as $\{1,\ldots,n\}$. All paths
referred to in this paper are paths of $T$ unless explicitly specified. \\

\noindent
A {\em path assignment} $\A$ to $\F$ is defined as a set assignment
where second universe is the vertex set $V$ of a given tree $T$ and
every second subset in the ordered pairs is a path in this tree. Formally, the definition is as follows.
\begin{align*}
  \A = \{ (S_i,P_i) \mid  S_i \in \F, P_i \subseteq V \text{ s.t. }T[P_i]
  \text{ is a path, } i \in I \}
\end{align*}
In other words, $P_i$ is the path on the tree $T$ assigned to $S_i$ in
$\A$. As mentioned before for set systems, the paths cover the whole
tree, i.e. $\bigcup_{i \in I}P_i = V$ \\

\noindent
Generalizing the definition of {\em feasibility} in \cite{nsnrs09} to
a set assignment, a path assignment $\A$ is defined to be {\em
  feasible} if there exists a bijection defined as follows.
\begin{align}
  \sigma: U \rightarrow V(T), \text{ such that }\sigma(S_i) = P_i \text{
    for all } i \in I, \sigma \text{ is a bijection}
\label{eq:stf}
\end{align}
%The assignment $\A$ is then called {\em Set Translation Feasible}.


\noindent
Let $X$ be a partially ordered set with $\preccurlyeq$ being the partial order on $X$.  
$mub(X)$ represents an element in $X$ which is a maximal upper bound on $X$.  $X_m \in X$ is a maximal upper bound of
$X$ if $\nexists X_q \in X$ such that $X_m
\preccurlyeq X_q$. \\

\noindent
The set $I$ represents the index set $[m]$. If index $i$ is used
without further qualification, it is meant to be $i \in I$. Any
function, if not defined on a domain of sets, when applied on a set is
understood as the function applied to 
each of its elements. i.e. for any function $f$ defined with domain $U$, the abuse of
notation is as follows; $f(S)$ is used instead of $\hat f(S)$ where
$\hat f(S) = \{y \mid y = f(x), x \in S\}$. \\

\noindent
When refering to a tree as $T$ it could be a reference to the tree
itself, or the vertices of the tree. This will be clear from the
context.\\

\noindent
Finally, an in-tree is a directed rooted tree in which all edges are directed toward to the root.
\section{Characerization of Feasible Tree Path Assignment} \label{feasible}
Consider a path assignment $\cA = \{(S_i, P_i) \mid S_i \in \cF, P_i
\text{ is a path from $T$}, i \in [m]\}$ to a set system $\cF = \{S_i \mid S_i
\subseteq U, i \in [m]\}$, were $T$ is a given tree, $U$
is the set system's universe and $m$ is the number of sets in $\cF$. We call $\cA$ an {\em Intersection
Cardinality Preserving Path Assignment (ICPPA)} if it has the following properties.

\begin{enumerate}
\item [i.]  $|S_i| = |P_i|$ for all $i \in [m]$
\item [ii.] $|S_i \cap S_j| = |P_i \cap P_j|$ for all $i,j \in [m]$
%\item [iii.] $|\bigcup_{i \in J} S_i| = |\bigcup_{i \in J} P_i|$ for
%  all $J \subseteq I$\footnote{TBD: this is needed now to fix some
%  proofs}
\item [iii.] $|S_i \cap S_j \cap S_k| = |P_i \cap P_j \cap P_k|$ for all $i,j,k \in [m]$
\end{enumerate}

\begin{lemma}
\label{lem:setminuscard}
  If $\cA$ is an ICPPA, and $(S_1, P_1),(S_2, P_2),(S_3, P_3) \in
  \cA$, then $|S_1 \cap (S_2 \setminus S_3)| = |P_1 \cap (P_2 \setminus P_3)|$.
\end{lemma}
\begin{proof}
$|S_1 \cap (S_2 \setminus S_3)| = |(S_1 \cap S_2) \setminus S_3| =
|S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3|$. Due to conditions (ii) and (iii) of
ICPPA, $|S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3| = |P_1 \cap P_2| - |P_1 \cap P_2 \cap
P_3| = |(P_1 \cap P_2) \setminus P_3| =  |P_1 \cap (P_2 \setminus
P_3)|$. Thus lemma is proven. \qed
\end{proof}

\begin{lemma}
  \label{lem:fourpaths} Consider four paths in a tree $Q_1, Q_2, Q_3,
  Q_4$ such that they have nonempty pairwise intersection and $Q_1,
  Q_2$ share a leaf. Then there exists distinct $i, j, k \in \{1,2,3,4\}$ such that, $Q_1 \cap Q_2 \cap Q_3 \cap Q_4 = Q_i \cap
  Q_j \cap Q_k$.
\end{lemma}
\begin{proof}
  {\em Case 1:} Consider $Q_3 \cap Q_4$ and let us call it $Q$. This is clearly a
  path (intersection of two paths is a path). 
% Since $Q_1, Q_2$ share a
%   leaf, the following are paths $Q_1 \setminus Q_2$, $Q_2 \setminus
%   Q_1$, $Q_1 \cap Q_2$ and they are mutually disjoint. 
  Suppose $Q$
  does not intersect with $Q_1 \setminus Q_2$, i.e. $Q \cap (Q_1
  \setminus Q_2) = \O$. Then $Q \cap
  Q_1 \cap Q_2 = Q \cap Q_2$. Similarly, if $Q \cap (Q_2 \setminus
  Q_1) = \O$, $Q \cap Q_1 \cap Q_2 = Q \cap Q_1$. Thus it is
  clear that if the intersection of any two paths does not intersect
  with any of the set differences of the remaining two paths, the
  claim in the lemma is true. 
  % Note that $Q_1 \setminus Q_2$ and $Q_2
%   \setminus Q_1$ are paths because $Q_1, Q_2$ share a leaf.\\ 
  {\em Case 2:} Let us consider the compliment of the previous case. i.e. the
  intersection of any two paths intersects with both the set
  differences of the other two. First let us consider $Q \cap (Q_1 \setminus Q_2) \ne
  \O$ and $Q \cap (Q_2 \setminus Q_1) \ne \O$, where $Q = Q_3 \cap
  Q_4$. Since $Q_1$ and
  $Q_2$ share a leaf, there is exactly one vertex at which they branch
  off from the path $Q_1 \cap Q_2$ into two paths $Q_1 \setminus Q_2$
  and $Q_2 \setminus Q_1$. Let this vertex be $v$. It is clear that if
  path $Q_3 \cap Q_4$, must intersect with paths $Q_1 \setminus Q_2$
  and $Q_2 \setminus Q_1$, it must contain $v$ since these are paths
  from a tree. Moreover, $Q_3 \cap Q_4$ intersects with $Q_1 \cap
  Q_2$ at exactly $v$ and only at $v$ which means that $Q_1 \cap Q_2$
  does not intersect with $Q_3 \setminus Q_4$ or $Q_4 \setminus Q_3$
  which contradicts initial condition of this case. Thus this
  case cannot occur and case 1 is the only possible scenario. \\
  Thus lemma is proven \qed
\end{proof}


\noindent
In the remaining part of this section we show that a path assignment is feasible if and only if
it is an ICPPA.  One direction of this claim is clear: that if a path assignment is feasible, then all
intersection cardinalities are preserved, that is the path assignment is an ICPPA.  The reason is that a
feasible path assignment has an associated bijection between $U$ and $V(T)$ such that the sets
map to paths.  The rest of the section is devoted to constructively proving that it is sufficient, for a path
assignment to be an ICPPA.  At a top-level, the constructive approaches refine the path assignment iteratively, such that at the end of each iteration we have a path assignment, and finally we have a family of bijections.
First we present and then prove the
  correctness of Algorithm \ref{perms}.  This algorithm refines the path assignment by considering pairs of paths that share a leaf.  

\begin{algorithm}[h]
\caption{Permutations from an ICPPA $\{(S_i,P_i) | i \in I\}$}
\label{perms}
\begin{algorithmic}
\STATE Let $\Pi_0=\{(S_i,P_i)| i \in I\}$\\
\STATE $j = 1$;
\label{shareleaf} \WHILE {There is $(P_1,Q_1), (P_2,Q_2) \in \Pi_{j-1}$ with $Q_1$ and
  $Q_2$ having a common leaf}
\STATE $\Pi_j=   \Pi_{j-1} \setminus \{(P_1,Q_1),(P_2,Q_2)\}$;
\label{setbreak}\STATE $\Pi_j = \Pi_j \cup \{(P_1 \cap P_2,Q_1 \cap Q_2), (P_1 \setminus P_2,Q_1 \setminus Q_2), (P_2 \setminus P_1, Q_2 \setminus Q_1)\}$;
\STATE $j = j+1$;
\ENDWHILE
\STATE $\Pi = \Pi_j$;
\STATE Return $\Pi$;
\end{algorithmic}
\end{algorithm}

\begin{lemma}
\label{lem:invar1}
  In Algorithm \ref{perms}, at the end of $j$th iteration, $j \ge 0$, of the while loop of 
  Algorithm \ref{perms}, the following invariants are maintained.
\begin{itemize}
\item {\em Invariant I:} $Q$ is a path in $T$ for each $(P,Q) \in
  \Pi_j$
\item {\em Invariant II:} $|P|=|Q|$ for each $(P,Q) \in \Pi_j$
\item {\em Invariant III:} For any two $(P,Q), (P',Q') \in \Pi_j$,
  $|P' \cap P''|=|Q' \cap Q''|$. 
\item {\em Invariant IV:} For any three, $(P',Q'), (P'',Q''),
  (P, Q) \in \Pi_j$,
  $|P' \cap P'' \cap P|=|Q' \cap Q'' \cap Q|$.
\end{itemize}
\end{lemma}
\begin{proof}
  Proof is by induction on the number of iterations, $j$. In the rest
  of the proof, the term ``new sets'' will refer to the new sets added
  in $j$th iteration as defined in line \ref{setbreak} of Algorithm
  \ref{perms}, i.e. the following three assignment pairs for
  some $(P_1,Q_1), (P_2,Q_2) \in \Pi_{j-1}$ where $Q_1$ and $Q_2$
  intersect and share a leaf: $(P_1 \cap P_2, Q_1 \cap Q_2)$, or $(P_1
  \setminus P_2, Q_1 \setminus Q_2)$, or $(P_2 \setminus P_1, Q_2
  \setminus Q_1)$.\\
  \noindent
  The base
  case, $\Pi_0 = \{(S_i,P_i) \mid i \in [m]\}$, is trivially true since it
  is the input which is an ICPPA.  Assume the lemma is true till the $j-1$
  iteration. Consider $j$th
  iteration:\\
  \noindent
  If $(P,Q)$, $(P',Q')$ and $(P'',Q'')$ are in $\Pi_{j}$ and
  $\Pi_{j-1}$, all the invariants are
  clearly true because they are from $j-1$ iteration.\\
  If $(P,Q)$ is in $\Pi_{j}$ and not in $\Pi_{j-1}$, then it must be
  one of the new sets added in $\Pi_j$. Since $(P_1,Q_1)$ and
  $(P_2,Q_2)$ are from $\Pi_{j-1}$ and $Q_1,Q_2$ intersect and have a
  common leaf, it can be verified that the
  new sets are also paths. \\
  By hypothesis for invariant III, invariant II also holds for $(P,Q)$
  no matter which new set in $\Pi_j$ it
  is.\\
  To prove invariant III, if $(P,Q)$ and $(P',Q')$ are not in
  $\Pi_{j-1}$, then they are both new sets and invariant III holds
  trivially (new sets are disjoint). Next consider $(P,Q), (P',Q') \in
  \Pi_j$ with only one of them, say $(P',Q')$, in $\Pi_{j-1}$. Then
  $(P,Q)$ is one of the new sets added in line \ref{setbreak}. It is
  easy to see that if $(P,Q)$ is $(P_1 \cap P_2, Q_1 \cap Q_2)$, then
  due to invariant IV in hypothesis, invariant III becomes true in
  this iteration. Similarly, using lemma \ref{lem:setminuscard}
  invariant III is proven if $(P, Q)$ is $(P_1 \setminus P_2, Q_1
  \setminus Q_2)$, or $(P_2 \setminus P_1, Q_2
  \setminus Q_1)$.\\
  To prove invariant IV, consider three assignments
  $(P,Q),(P',Q'),(P'',Q'')$. If at least two of these pairs are in not
  $\Pi_{j-1}$, then they are any two of the new sets. Note that these
  new sets are disjoint and hence if $(P',Q'), (P'',Q'')$ are any of
  these sets, $|P \cap P' \cap P''|=|Q \cap Q' \cap Q''|=0$ and
  invariant IV is true. Now we consider the case if at most one of
  $(P,Q),(P',Q'),(P'',Q'')$ is not in $\Pi_{j-1}$. If none of them are
  not in $\Pi_{j-1}$ (i.e. all of them are in $\Pi_{j-1}$), invariant
  IV is clearly true. Consider the case where exactly one of them is
  not in $\Pi_{j-1}$. w.l.o.g let that be $(P,Q)$ and it could be any
  one of the new sets. If $(P,Q)$ is $(P_1 \cap P_2, Q_1 \cap Q_2)$,
  from lemma \ref{lem:fourpaths} and invariant III hypothesis,
  invariant IV is proven. Similarly if $(P,Q)$ is any of the other new
  sets, invariant IV is proven by also using lemma
  \ref{lem:setminuscard}. \qed

\end{proof}

\noindent
It can be observed that the output of algorithm \ref{perms} is such
that every leaf is incident on at most a single path in the new set of
assignments. This is due to the loop condition at line
\ref{shareleaf}. Let $v_1$ be the leaf incident on path $P_i$. Assign
to it any one element from $S_i \setminus \bigcup_{i \ne j}
S_j$. Remove $(S_i, P_i)$ from assignments and add $(\{x_1\},
\{v_1\}), (S_i \setminus \{x_1\}, P_i \setminus \{v_1\})$. Now all
assignments except single leaf assignments are paths from the subtree
$T_0 = T \setminus \{v \mid v \text{ is a leaf in } T\}$. This is the
function of Algorithm \ref{leafasgn}.

% exclusively on the spine of the caterpillar. Consider the spine to be an
% interval and run ICPIA algorithm on it to get the required
% permutation. Algorithm \ref{leafasgn} makes this clear.

\begin{algorithm}[h]
\caption{Leaf assignments from an ICPPA $\{(S_i,P_i) | i \in I\}$}
\label{leafasgn}
\begin{algorithmic}
\STATE Let $\Pi_0=\{(S_i,P_i)| i \in [m]\}$. Paths are such that no
two paths $P_i, P_j, i \ne j$ share a leaf.\\
\STATE $j = 1$\\
\WHILE {there is a leaf $v$ and a unique $(S_{i_1}, P_{i_1})$ such that $v \in P_{i_1}$}
\STATE $\Pi_j=   \Pi_{j-1} \setminus \{(S_{i_1}, P_{i_1})\}$\\
\STATE $X = S_{i_1} \setminus \bigcup_{i \ne i_1, i \in
  I}S_i$
\IF{$X$ is empty} 
\STATE exit 
\ENDIF;
\STATE Let $x = $ arbitrary element from $X$ \vspace{2mm}

\STATE $\Pi_j = \Pi_j \cup \{(S_{i_1} \setminus \{x\}),(P_{i_1} \setminus
  \{v\}), (\{x\},\{v\})\}$\\
\STATE $j = j+1$\\
\ENDWHILE
\STATE $\Pi = \Pi_j$\\
\STATE Return $\Pi$\\
\end{algorithmic}
\end{algorithm}

\begin{lemma}
\label{lem:invar3}
  In Algorithm \ref{leafasgn},for all $j \geq 0$, at the end of the $j$th iteration the four invariants given in lemma \ref{lem:invar1} are valid.
% Moreover, $X$ as defined in the algorithm  is non-empty if this is an ICPPA.
\end{lemma}
\begin{proof}
  First we see that $X = S_{i_1} \setminus \bigcup_{i \ne i_1, i \in
    I}S_i$ is non empty in every iteration for an ICPPA. Suppose $X$
  is empty. We know that $v \in P_{i_1} \setminus \bigcup_{i \ne i_1, i \in
    I}P_i$ since $v$ is in the unique path $P_{i_1}$. Since this is an
  ICPPA $|S_{i_1}| = |P_{i_1}|$. For any $x \in S_{i_1}$ it is
  contained in at least two sets due to our assumption. Let $S_{i_2}$ be a second set that
  contains $x$. We know $v \notin P_{i_2}$. Therefore there cannot
  exist a permutation that maps elements of $S_{i_2}$ to
  $P_{i_2}$. This contradicts our assumption that this is an ICPPA. Thus $X$ cannot be empty.


  We use mathematical induction on the number of iterations for this
  proof. The term ``new sets'' will refer to the sets added in $\Pi_j$
  in the $j$th iteration, i.e. $(P' \setminus
  \{x\},Q' \setminus \{v\})$ and $(\{x\},\{v\})$ for some $(P',Q')$
  in $\Pi_{j-1}$ such that $v$ is a leaf and $Q'$ is the unique path
  incident on it.\\
  For $\Pi_0$ all invariants hold because it is output from
  algorithm \ref{perms} which is an ICPPA. Hence base case is proved.  Assume the
  lemma holds for $\Pi_{j-1}$. Consider $\Pi_j$ and any $(P,Q) \in
  \Pi_j$. If $(P,Q) $ is in $ \Pi_j$ and $\Pi_{j-1}$ invariants I and II are
  true because of induction assumption. If it is only in $\Pi_j$, then it is $\{(P' \setminus
  \{x\}),(Q' \setminus \{v\})$ or $(\{x\},\{v\})$ for some $(P',Q')$
  in $\Pi_{j-1}$. By definition, $x$ is an element in $P'$ (as defined in the
  algorithm) and $v$ is a leaf in $Q'$. If $(P,Q)$ is $\{(P' \setminus \{x\}),(Q' \setminus \{v\})$,
  $Q$ is a path since only a leaf is removed from path $Q'$. We know $|P'| = |Q'|$,
  therefore $|P' \setminus \{x\}| = |Q' \setminus \{v\}|$. Hence in this case invariants
  I and II are obvious. It is easy to see these invariants hold if $(P,Q)$ is $(\{x\},\{v\})$.


  For invariant III consider $(P_1,Q_1),(P_2,Q_2)$ in $\Pi_j$. If both
  of them are also in $\Pi_{j-1}$, claim is proved. If one of them is
  not in $\Pi_{j-1}$ then it has to be $\{(P' \setminus
  \{x\}),(Q' \setminus \{v\})$ or $(\{x\},\{v\})$ for some $(P',Q')$
  in $\Pi_{j-1}$. Since by definition, $Q'$ is the only path with $v$ and $P'$ the
  only set with $x$ in the
  previous iteration, $|P_1 \cap (P' \setminus \{x\})| = |P_1 \cap P'|$
  and $|Q_1 \cap (Q' \setminus \{v\})| = |Q_1 \cap Q'|$ and $|P_1 \cap
  \{x\}| = 0, Q_1 \cap \{v\} = 0$. Thus invariant III is also proven.

  \noindent
  To prove invariant IV, consider $(P_1,Q_1),(P_2,Q_2), (P_3,Q_3)$ in
  $\Pi_j$. If exactly one of them, say $P_3 \notin \Pi_{j-1}$, it is one of the new sets. By the same argument used to
  prove invariant III, $|P_1 \cap P_2 \cap (P'
  \setminus \{x\})| = |P_1 \cap P_2 \cap P'|$ 
  and $|Q_1 \cap Q_2 \cap (Q' \setminus \{x\})| = |Q_1 \cap Q_2 \cap
  Q'|$. Since $P_1, P_2, P'$ are all in $\Pi_{j-1}$, by induction hypothesis
  $|P_1 \cap P_2 \cap P'| = |Q_1 \cap Q_2 \cap Q'|$. Also $|P_1 \cap
  P_2 \cap \{x\}| = 0, Q_1 \cap Q_2 \cap \{v\} = 0$. 
  If two or more of them are not in $\Pi_{j-1}$, then it can
  be verified that $|P_1
  \cap P_2 \cap P_3| = |Q_1 \cap Q_2 \cap Q_3|$ since the new sets
  in $\Pi_j$ are either disjoint or as follows: assuming $P_1, P_2
  \notin \Pi_{j-1}$ and new sets are derived from $(P', Q'), (P'', Q'') \in
  \Pi_{j-1}$ with $x_1, x_2$
  exclusively in $P_1, P_2$, $(\{x_1\},\{v_1\}), (\{x_2\},\{v_2\})
  \in \Pi_j $ thus $v_1, v_2$ are exclusively in $Q_1, Q_2$ resp. it
  follows that
$|P_1
  \cap P_2 \cap P_3| = |(P' \setminus \{x_1\}) \cap (P'' \setminus
  \{x_2\}) \cap P_3| = |P' \cap P'' \cap P_3| = |Q' \cap Q'' \cap Q_3|
  = |(Q' \setminus \{v_1\} \cap Q'' \setminus \{v_2\} \cap Q_3| =
  |Q_1 \cap Q_2 \cap Q_3|$. Thus invariant
  IV is also proven.
  \qed
\end{proof}

\noindent
Using algorithms \ref{perms} and \ref{leafasgn} we prove the following
theorem.

\begin{theorem}
\label{th:perm}
  If $\cA$ is an ICPPA, then there exists a bijection $\sigma : U
\rightarrow V(T)$ such that $\sigma(S_i) = P_i$ for all $i \in I$
\end{theorem}
\begin{proof}
This is a contructive proof. First, the given ICPPA $\cA$ and tree $T$ are given as input to Algorithm
\ref{perms}. This yields a ``filtered'' ICPPA as the output which is
input to Algorithm \ref{leafasgn}.
It can be observed that the output of Algorithm \ref{leafasgn} is a set of path
assignments to sets and one-to-one assignment of elements of $U$ to
each leaf of $T$. To be precise, it would be of the form $\cB_0 =
\cA_0 \cup \cL_0$. The leaf assignments are defined in $\cL_0
= \{ (x_i,v_i) \mid x_i \in U, v_i \in T, x_i \ne x_j, v_i \ne v_j, i \ne j, i,j \in [k] \}$ where $k$ is the
number of leaves in $T$. The path assignments are defined in $\cA_0
\subseteq \{(S_i',P_i') \mid S_i' \subseteq U_0, P_i' \text{ is a path
  from } T_0\}$ where $T_0$ is the tree obtained by removing all the
leaves in $T$ and $U_0 = U \setminus \{ x \mid x \text{ is assigned to
  a leaf in }\cL_0 \}$. Now we have a subproblem of finding the
permutation for the path assignment $\cA_0$ which has paths from tree
$T_0$ and sets from universe $U_0$. Now we repeat the procedure and the path assignment $\cA_0$ and tree $T_0$
is given as input to Algorithm \ref{perms}. The output of this
algorithm is given to Algorithm \ref{leafasgn} to get a new
union of path and leaf assignments $\cB_1 =
\cA_1 \cup \cL_1$ defined similar to $\cB_0, \cL_0, \cA_0$. In
general, the two algorithms are run on
path assignment $\cA_{i-1}$ with paths from tree $T_{i-1}$ to get a new
subproblem with path assignment $\cA_i$ and tree $T_{i}$. $T_i$ is
the subtree of $T_{i-1}$ obtained by removing all its leaves. More importantly, it gives leaf
assignments $\cL_{i}$ to the leaves in tree $T_{i-1}$. This is
continued until we get a subproblem with path assignment $\cA_{d-1}$ and
tree $T_{d-1}$ for some $d \le n$ which is just a
path. From the last lemma we know that $\cA_{d-1}$ is an
ICPPA. Another observation is that an ICPPA with all its tree paths
being intervals (subpaths from a path) is nothing but an ICPIA\cite{nsnrs09}.
Let $\cA_{d-1}$ be equal to $\{(S_i'',P_i'') \mid S_i'' \subseteq U_{d-1}, P_i'' \text{ is a path
  from } T_{d-1} \}$. It is true that the paths $P_i''$s
may not be precisely an interval in the sense of consecutive integers
because they are some nodes from a tree. However, it is easy to see that
the nodes of $T_{d-1}$ can be ordered from left to right and ranked to get
intervals $I_i$ for every path $P_i''$ as follows. $I_i = \{[l,r]
\mid l = \text{ the lowest rank of the nodes in }P_i'', r = l+|P_i''|-1
\}$. Let asssignment $\cA_d$ be with the renamed paths. $\cA_d = \{ (S_i'', I_i) \mid (S_i'', P_i'') \in \cA_{d-1}
\}$. What has been effectively done is renaming the nodes in $T_{d-1}$
to get a tree $T_d$.
The ICPIA $\cA_d$ is now in the format that the ICPIA algorithm
requires which gives us the permutation $\sigma' : U_{d-1} \rightarrow T_{d-1}$

\noindent
$\sigma'$ along with all the leaf assignments $\cL_i$
gives us the permutation for the original path assignment $\cA$.
More precisely, the permutation for tree path assignment $\cA$ is defined as
follows. $\sigma: U \rightarrow T$ such that the following
is maintained.
\begin{align*}
 \sigma(x) &= \sigma'(x),   \text{ if } x \in U_{d-1} \\
           &= \cL_i(x),     \text{ where $x$ is assigned to a leaf in a
             subproblem $\cA_{i-1}, T_{i-1}$}
\end{align*}

\noindent
To summarize, run algorithm \ref{perms} and
\ref{leafasgn} on $T$. After the leaves have been assigned to specific
elements from $U$, remove all leaves from $T$ to get new tree
$T_0$. The leaf assignments are in $\cL_0$. Since only leaves were removed $T_0$ is indeed a tree. Repeat
the algorithms on $T_0$ to get leaf assignments $\cL_{1}$. Remove the
leaves in $T_0$ to get $T_1$ and so on until the pruned tree $T_d$
is a single path. Now run ICPIA algorithm on $T_d$ to get
permutation $\sigma'$. The relation $\cL_0 \cup \cL_1 \cup .. \cup
\cL_{d} \cup \sigma'$ gives the bijection required in the original problem.\qed
\end{proof}

\section{Finding an assignment of tree paths to a set system} \label{decompos}
In the previous section we have shown that the problem of finding a Tree Path Asssignment to an input $(\cF,T)$ is equivalent to finding an ICPPA to $\cF$ in tree $T$.  
In this section we characterize those set systems that have an ICPPA in a given tree.  As a consequence of this characterization we identify two sub-problems that must be solved to obtain an ICPPA.  We do not solve the problem and in the next section show that finding an ICPPA in a given tree is GI-Complete.  

\noindent
A set system can be concisely represented by a binary matrix where the
row indices denote the universe of the set system and the column
indices denote each of the sets. Let the binary matrix be $M$ with
order $n \times m$, the set system be $\cF = \{S_i \mid i \in [m]\}$,
universe of set system $U = \{x_1, \dots ,x_n\}$. If $M$ represents $\cF$, $|U| = n, |\cF| =
m$. Thus $(i,j)$th element of $M$, $M_{ij} = 1$ iff $x_i \in S_j$. If $\cF$ has a feasible tree path assignment (ICPPA) $\cA =
\{(S_i,P_i) \mid i \in [m]\}$, then we
say its corresponding matrix $M$ has an ICPPA. Conversly
we say that a matrix $M$ has an ICPPA if there exists an ICPPA $\cA$ as defined
above.\\
\noindent
We now define the strict intersection graph or overlap graph of $\cF$. This graph occurs at many
places in the literature, see for example \cite{kklv10, wlh02, nsnrs09}.  The vertices of the graph
correspond to the sets in $\cF$.  An edge is present between vertices of two sets iff the
corresponding sets have a nonempty intersection and none is contained
in the other. Formally, intersection graph is $G_f = (V_f, E_f)$ such
that $V_f = \{v_i \mid S_i \in \cF\}$ and $E_f = \{(v_i, v_j) \mid S_i
\cap S_j \ne \O \text{ and }S_i \nsubseteq S_j, S_j \nsubseteq S_i
\}$.  We use this graph to decompose $M$ as described in \cite{wlh02,nsnrs09}.  
A prime sub-matrix of $M$ is defined as the
matrix formed by a set of columns of $M$ which correspond to a
connected component of the graph $G_f$.  Let us denote the prime
sub-matrices by $M_1,\ldots,M_p$ each corresponding to one of the $p$
components of $G_f$. Clearly, two distinct matrices have
a distinct set of columns.  Let $col(M_i)$ be the set of columns in
the sub-matrix $M_i$.  The support
of a prime sub-matrix $M_i$ is defined as $supp(M_i) = \displaystyle \bigcup_{j \in  col(M_i)}S_j$. 
Note that for each $i$, $supp(M_i) \subseteq
U$.  For a set of prime sub-matrices $X$ we define
$supp(X) = \displaystyle \bigcup_{M \in X} supp(M)$. \\


\noindent
Consider the relation
$\preccurlyeq$ on the prime sub-matrices $M_1, \ldots, M_p$ defined as
follows: 
\begin{equation} 
\nonumber \{(M_i,M_j) | \mbox{ A set } S \in
  M_i \mbox{ is contained in a set } S' \in M_j\} \cup \{(M_i,M_i) | 1
  \leq i \leq p\} 
\end{equation}

\noindent
This relation is the same as that defined in \cite{nsnrs09}. The prime
submatrices and the above relation can be defined for any set
system. We will use this structure of prime submatrices to present our
results on an an ICPPA for a set system $\cF$. Recall the following
lemmas, and theorem that $\preccurlyeq$ is a partial order, from
\cite{nsnrs09}.

\begin{lemma} \label{lem:containment}
Let $(M_i,M_j) \in \preccurlyeq$.  Then there is a set $S' \in M_j$ such that for each $S \in M_i$, $S \subseteq S'$. 
\end{lemma}
\begin{lemma}
For each pair of prime sub-matrices, either $(M_i,M_j) \not\in \preccurlyeq$ or $(M_j,M_i) \not\in \preccurlyeq$.
%If $(M_i,M_j) \in \preccurlyeq$ and $(M_j,M_i) \in \preccurlyeq$, then $i = j$ and $|M_i| = 1$.
\end{lemma}
\begin{lemma}
If $(M_i,M_j) \in \preccurlyeq $ and $(M_j,M_k) \in \preccurlyeq$, then $(M_i,M_k) \in \preccurlyeq$.
\end{lemma}
\begin{lemma} \label{lem:twoparents}
If $(M_i,M_j) \in \preccurlyeq$ and $(M_i,M_k) \in \preccurlyeq$, then
either $(M_j,M_k) \in \preccurlyeq$ or $(M_k,M_j) \in \preccurlyeq$. 
\end{lemma}
\begin{theorem} \label{thm:partitionold}
  $\preccurlyeq$ is a partial order on the set of prime sub-matrices
  of $M$.  Further, it uniquely partitions the prime sub-matrices of
  $M$ such that on each set in the partition $\preccurlyeq$ induces a
  total order.
\end{theorem}
For the purposes of this paper, we refine the total order mentioned in
Theorem \ref{thm:partitionold}. We do this by identifying an in-tree
rooted at each maximal upper bound under $\preccurlyeq$.  Each of
these in-trees will be on disjoint vertex sets, which in this case
would be disjoint sets of prime-submatrices.  The in-trees are
specified by selecting the appropriate edges from the Hasse diagram
associated with $\preccurlyeq$.  Let $\cI$ be the following set:
\begin{align*}
  \cI = \{ (M_i,M_j) \in \preccurlyeq \mid \nexists M_k s.t. M_i \preccurlyeq M_k, M_k \preccurlyeq M_j
  \} \cup \{ (M_i,M_i), i \in [p] \}
\end{align*}

\begin{theorem} \label{thm:partition} Consider the directed graph $X$
  whose vertices correspond to the prime sub-matrices, and the edges
  are given by $\cI$.  Then, $X$ is a vertex disjoint collection of
  in-trees and the root of each in-tree is a maximal upper bound in
  $\preccurlyeq$.
\end{theorem}
\begin{proof}
To observe that $X$ is a collection of in-trees, we observe that for         
vertices corresponding to maximal upper bounds, no out-going edge is
present in $X$.  Secondly, for each other element, exactly one
out-going edge is chosen (due to lemma \ref{lem:twoparents} and the
condition in set $\cI$ definition), and for the 
minimal lower bound, there is no in-coming edge.  Consequently, $X$ is
acyclic, and since each vertex has at most one edge leaving it, it
follows that $X$ is a collection of in-trees, and for each in-tree,
the root is a maximal upper bound in $\preccurlyeq$.  Hence the
theorem. \qed
\end{proof}
Let the partition of $X$ given by Theorem \ref{thm:partition} be
$\{X_1,\ldots,X_r\}$.  Further, each in-tree itself  
can be layered based on the distance from the root.  The root is
considered to be at level zero. For $j \geq 0$, Let $X_{i,j}$ denote
the set of prime matrices in level $j$ of in-tree $X_i$.   

\begin{lemma}
\label{lem:subicppa}
Let $M$ be a matrix and let $X$ be the directed graph whose vertices
are in correspondence with the prime submatrices of $M$.  Further let
$\{X_1,\ldots,X_r\}$ be the partition of $X$ into in-trees as defined
above. 
Then, matrix $M$ has an ICPPA in tree $T$ iff $T$ can be partitioned
into vertex disjoint subtrees 
 $\{T_1, T_2, \dots T_r\}$ such that, for each $1 \leq i \leq r$, the
 set of prime sub-matrices corresponding to vertices in $X_i$ has an
 ICPPA in $T_i$. 
\end{lemma}
\begin{proof}
Let us consider the reverse direction first.  Let us assume that $T$
can be partitioned into $T_1, \ldots, T_r$ such 
that for each $1 \leq i \leq r $, the set of prime sub-matrices
corresponding to vertices in $X_i$ has an ICPPA in $T_i$.  It is clear
from the properties of the partial order $\preccurlyeq$ that these
ICPPAs naturally yield an ICPPA  of $M$ in $T$.  The main property
used in this inference is that for each $1 \leq i \neq j \leq r$,
$supp(X_i) \cap supp(X_j) = \phi$.   

\noindent
To prove the forward direction, we show that if $M$ has an ICPPA, say
$\cA$, in $T$, then there exists 
  a partition of $T$ into vertex disjoint subtree $T_1, \ldots, T_r$
  such that for each $1 \leq i \leq r$, the set of prime sub-matrices
  corresponding to vertices in $X_i$ has an ICPPA in $T_i$.  For each
  $1 \leq i \leq r$, we define based on $\cA$ a subtree  
$T_i$ corresponding to $X_i$.  We then argue that the trees thus
defined are vertex disjoint, and complete the proof. 
 Consider $X_i$ and consider the prime sub-matrix in $X_{i,0}$.
 Consider the paths assigned under $\cA$ to the sets in the prime
 sub-matrix in $X_{i,0}$.  Since the component in $G_f$ corresponding
 to this matrix is a connected component, it follows that union of
 paths assigned to this prime-submatrix is a subtree of $T$.  We call
 this sub-tree $T_i$.  All other prime-submatrices in $X_i$ are
 assigned paths in $T_i$ since $\cA$ is an ICPPA, and the support of
 other prime sub-matrices in $X_i$ are contained in the support of the
 matrix in $X_{i,0}$.  Secondly, for each $1 \leq i \neq j \leq r$,
 $supp(X_i) \cap supp(X_j) = \phi$, and since $\cA$ is an ICPPA, it
 follows that $T_i$ and $T_j$ are vertex disjoint.  Finally, since
 $|U| = |V(T)|$, it follows that $T_1, \ldots, T_r$ is a partition of
 $T$ into vertex disjoint sub-trees such that for each $1 \leq i \leq
 r$, the set of matrices corresponding to nodes in $X_i$ has an ICPPA
 in $T_i$.  Hence the lemma. \qed
\end{proof}
 The essence of the following lemma is that an ICPPA only needs to be
 assigned to the prime sub-matrix corresponding to the root of each
 in-tree, and all the other prime sub-matrices only need to have an
 Intersection Cardinality Preserving Interval Assignments (ICPIA).
 Recall, an ICPIA is an assignment of intervals to sets such that the
 cardinality of an assigned interval is same as the cardinality of the
 interval, and the cardinality of intersection of any two sets is same
 as the cardinality of the intersection of the corresponding
 intervals.  It is shown in \cite{nsnrs09} that the existence of an
 ICPIA is a necessary and sufficient condition for a matrix to have
 COP.  
We present the pseudo-code to test if $M$ has an ICPPA in $T$. 
\begin{lemma} \label{lem:rooticppa}
Let $M$ be a matrix and let $X$ be the directed graph whose vertices
are in correspondence with the prime submatrices of $M$.  Further let
$\{X_1,\ldots,X_r\}$ be the partition of $X$ into in-trees as defined
earlier in this section. 
Let $T$ be the given tree and let $\{T_1, \ldots, T_r\}$ be a given
partition of $T$ into vertex disjoint sub-trees. 
Then, for each $1 \leq i \leq r$, the set of matrices corresponding to
vertices of $X_i$ has an ICPPA in $T_i$ if and only if the matrix in
$X_{i,0}$ has an ICPPA in $T_i$ and all other matrices in $X_i$ have
an {\bf {\em ICPIA}}. 
\end{lemma}
\begin{proof}
The proof is based on the following fact- $\preccurlyeq$ is a partial
order and $X$ is a digraph which is the disjoint 
union of in-trees.  Each edge in the in-tree is a containment
relationship among the supports of the corresonding
sub-matrices. Therefore, any ICPPA to a prime sub-matrix that is not
the root is contained in a path assigned to the sets in the parent
matrix.  Consequently, any ICPPA to the prime sub-matrix that is not
at the root is an ICPIA, and any ICPIA can be used to construct an
ICPPA to the matrices corresponding to nodes in $X_i$ provided the
matrix in the root has an ICPPA in $T_i$.   Hence the lemma. \qed
\end{proof}
Lemma \ref{lem:subicppa} and Lemma \ref{lem:rooticppa} point out two
algorithmic challenges in finding an ICPPA for a given set system
$\cF$ in a tree $T$.  Given $\cF$, finding $X$ and its partition
$\{X_1,\ldots,X_r\}$ into in-trees can be done in polynomial time.  On
the other hand, as per lemma \ref{lem:subicppa} we need to parition
$T$ into vertex disjoint sub-trees $\{T_1, \ldots, T_r\}$ such that
for each $i$, the set of matrices corresponding  to nodes in $X_i$
have an ICPPA in $T_i$.  This seems to be a challenging step, and it
must be remarked that this step is easy when $T$ itself is a path, as
each individual $T_i$ would be sub-paths.  The second algorithmic
challenge is identified by lemma \ref{lem:rooticppa} which is to
assign an ICPPA from a given tree to the matrix associated with the
root node of $X_i$.   
\begin{algorithm}[h]
\caption{Algorithm to find an ICPPA for a matrix $M$ on tree $T$: $main\_ICPPA(M, T$)}
\label{al:icppa-main}
\begin{algorithmic}
\STATE Identify the prime sub-matrices. This is done by constructing
the strict overlap graph and identify connected components.  Each
connected component yields a prime sub-matrix.   \\ 
\STATE Construct the partial order $\preccurlyeq$ on the set of prime
sub-matrices.  \\ 
\STATE Construct the partition $X_1,\ldots,X_r$ of the  prime
sub-matrices induced by $\preccurlyeq$ \\
\STATE For each $1 \leq i \leq r$, Check if all matrices except those
in $X_{i,0}$ has an ICPIA.  If a matrix does not have ICPIA exit with
a negative answer.  To check for the existence of ICPIA, use the
result in \cite{nsnrs09}. 
\STATE  Find a partition of $T_1, \ldots, T_r$ such that matrices in
$X_{i,0}$ has an ICPPA in $T_i$.  If not such 
partition exists, exit with negative answer.  
\end{algorithmic}
\end{algorithm}
\section{Complexity of Tree Path Assignment-A Discussion} \label{complexity}
Recall that the input to the Tree Path Assignment question is an order
pair $(\cF,T)$ where $\cF$ is a family of subsets of an universe $U$,
and $T$ is a tree such that $|V(T)| = |U|$.  The question is to come
up with a bijection from 
$U$ to $V(T)$ such that the image of each set in $\cF$ is a path in
$T$.  We show that this problem is at least as hard as the problem of
testing if two given path chordal graphs are isomorphic.   
\begin{theorem} \label{thm:isocomp}
Tree Path Assignment is isomorphism-complete.
\end{theorem}
\begin{proof}
  It is well known (see for example \cite{kklv10}) that testing
  isomorphism of path chordal graphs is isomorphism complete.  We show
  a reduction of path chordal graph isomorphism to tree path
  assignment.  Given $G_1$ and $G_2$ two path chordal graphs, let
  $T_2$ be the clique tree of $G_2$ obtained from say \cite{gav78}.
  The nodes of $T_2$ correspond to the maximal cliques of $G_2$ and
  each vertex of $G_2$ corresponds to a path in $G_2$.  This is a
  well-known characterization of path chordal graphs and $T_2$ can be
  computed in polynomial time.  In $G_1$, let $S_v$ denote the maximal
  cliques of $G_1$ that contain $v$.  This can be computed in
  polynomial time as $G_1$ is path chordal, and all chordal graph only
  have a linear number of maximal cliques.  The universe $U$
  corresponds bijectively to the set of maximal cliques in $G_1$, and
  $\cF = \{S_v | v \in V(G_1)\}$.  Now, we claim that $(\cF, T_2)$ has
  a tree path assignment if and only if $G_1$ and $G_2$ are
  isomorphic.  This is clear since for each vertex $v \in G_1$, there
  is an associated $S_v$ which is the set of maximal cliques
  containing $v$.  In $G_2$, each vertex corresponds to a path in
  $T_2$, and the nodes on this path corresponds to the maximal cliques
  in $G_2$.  Consequently, a tree path assignment will naturally yield
  an isomorphism between $G_1$ and $G_2$, and vice versa.  Therefore,
  Tree Path Assignment is isomorphism-complete. \qed
\end{proof}
\subsection{Consecutive Ones Testing is in Logspace}
While Tree Path Assignment is isomorphism-complete, it is polynomial
time solvable when the given tree is a path.  Indeed, in this case we
encounter a restatement of matrices with the COP.  The known
approaches to testing for COP fall into two categories: those that
provide a witness when the input matrix does not have COP, and those
that do not provide a witness.  The first linear time algorithm for
testing COP for a binary matrix was using a data structure called PQ
trees, which represent all COP orderings of $M$, invented by
\cite{bl76}. There is a PQ tree for a matrix iff the matrix has COP.
Indeed, this is an algorithmic characterization of the consecutive
ones property and the absence of the PQ-tree does not yield any
witness to the reason for failure.  A closely related data structure
is the generalized PQ tree in \cite{mcc04}.  In generalized PQ tree
the P and Q nodes are called prime and linear nodes. Aside from that,
it has a third type of node called degenerate nodes which is present
only if the set system does not have COP \cite{mcc04}.  Using the idea
of generalized PQ tree, \cite{mcc04} proves that checking for
bipartiteness in the certain incomparability graph is sufficient to
check for COP.  \cite{mcc04} invented a certificate to confirm when a
binary matrix does not have COP.  \cite{mcc04} describes a graph
called incompatibility graph of a set system $\cF$ which has vertices
$(a,b), a \ne b$ for every $a, b \in U$, $U$ being the universe of the
set system. There are edges $((a,b),(b,c))$ and $((b,a),(c,b))$ if
there is a set $S \in \cF$ such that $a, c \in S$ and $b \notin S$. In
other words the vertices of an edge in this graph represents two
orderings that cannot occur in a consecutive ones ordering of $\cF$.
\begin{theorem}[Theorem 6.1, \cite{mcc04}]
  Let $\cF$ be an arbitrary set family on domain $V$. Then $\cF$ has
  the consecutive ones property if and only if its incompatibility
  graph is bipartite, and if it does not have the consecutive ones
  property, the incompatibility graph has an odd cycle of length at
  most $n+3$.
\end{theorem}
This theorem gives a certificate as to why a given matrix does not
have COP.  Similarly, the approach of testing for an ICPIA in
\cite{nsnrs09} also gives a different certificate- a prime sub-matrix
that does not have an ICPIA.  Further, the above theorem can be used
to check if a given matrix has COP in logspace by checking if its
incompatibility graph is bipartite. \cite{rei84} showed that checking
for bipartiteness can be done in logspace. Thus we conclude that
consecutive ones testing can be done in logspace.

\noindent
More recently, \cite{kklv10} showed that interval graph isomorphism
can be done in logspace. Their paper proves that a canon for interval
graphs can be calculated in logspace using an interval hypergraph
representation of the interval graph with each hyperedge being a set
to which an interval shall be assigned by the canonization
algorithm. An overlap graph (subgraph of intersection graph, edges
define only strict intersections and no containment) of the hyperedges
of the hypergraph is created and canons are computed for each overlap
component. The overlap components define a tree like relation due to
the fact that two overlap components are such that either all the
hyperedges of one is disjoint from all in the other, or all of them
are contained in one hyperedge in the other. This is similar to the
containment tree defined in \cite{nsnrs09} and in this paper. Finally
the canon for the whole graph is created using logspace tree
canonization algorithm from \cite{sl92}. The interval labelling done
in this process of canonization is exactly the same as the problem of
assigning feasible intervals to a set system, and thus the problem of
finding a COP ordering in a binary matrix \cite{nsnrs09}.

\begin{theorem}[Theorem 4.7, \cite{kklv10}] 
\label{th:canonlabel}
Given an interval hypergraph $\cH$, a canonical interval labeling $l_H$ 
for $H$ can be computed in FL.
\end{theorem}


We present the following reduction to see that COP testing is
indeed in logspace. Given a binary matrix $M$ of order $n \times m$,
let $S_i = \{j \mid M[j,i]=1 \}$. Let $\cF = \{S_i \mid i \in [m] \}$
be this set system. Construct a hypergraph $\cH$ with its vertex set
being $\{1, 2, \dots n\}$. The edge set of $\cH$ is isomorphic to
$\cF$. Thus every edge in $\cH$ represents a set in the given set
system $\cF$. Let this mapping be $\pi: E(\cH) \rightarrow \cF$. It is
easy to see that if $M$ has COP, then $\cH$ is an interval
hypergraph. From theorem \ref{th:canonlabel}, it is clear that the
interval labeling $l_{\cH}: V(\cH) \rightarrow [n]$ can be calculated
in logspace. Construct sets $I_i = \{ \l_{\cH}(x) \mid x \in E, E \in
E(\cH), \pi(E) = S_i\}$, for all $i \in [m]$. Since $\cH$ is an
interval hypergraph, $I_i$ is an interval for all $i \in [m]$, and is
the interval assigned to $S_i$ if $M$ has COP.

Now we have the following corollary.
\begin{corollary}
\label{cor:coplog}
  If a binary matrix $M$ has COP then the interval assignments to each
  of its columns can be calculated in FL.
\end{corollary}

\noindent
Finally, we conclude by asking about the complexity of Tree Path
Assignment restricted to other subclasses of trees.  In particular, is
Tree Path Assignment in caterpillars easier than Tree Path assignment
in general trees.






%\section {Acknowlegements:} 
%TBD

%\bibliographystyle{plainnat}
\bibliographystyle{alpha} %to have only [i] type of citation
\bibliography{cop-variants}

\end{document}
