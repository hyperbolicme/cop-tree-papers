%%
% Author: N S Narayanaswamy and Anju Srinivasan Zabil
%%


%\documentclass{../../lib/llncs}
\documentclass{llncs}

\usepackage{fullpage}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{comment}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{natbib}


\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\DeclareMathAlphabet{\mathcalligra}{T1}{calligra}{m}{n}

% for Natbib
%\bibpunct{(}{)}{;}{a}{,}{,}

\def\Remark{\noindent{\bf Remark:~}}
\long\def\denspar #1\densend {#1}
\def\DEF{\stackrel{\rm def}{=}}

% \def\mathbi#1{\textbf{\em #1}}  % bold italic font in math mode
% use \mathfrak, \mathsf, \mathbb,\mathpzc, \mathcalligra for differnt math fonts. some
%  have small letters too.

%%% string defs
\def\cA{{\cal A}}
\def\cB{{\cal B}}
\def\cC{{\cal C}}
\def\cD{{\cal D}}
\def\cE{{\cal E}}
\def\cF{{\cal F}}
\def\cG{{\cal G}}
\def\cH{{\cal H}}
\def\cI{{\cal I}}
\def\cJ{{\cal J}}
\def\cK{{\cal K}}
\def\cL{{\cal L}}
\def\cM{{\cal M}}
\def\cN{{\cal N}}
\def\cO{{\cal O}}
\def\cP{{\cal P}}
\def\cQ{{\cal Q}}
\def\cR{{\cal R}}
\def\cS{{\cal S}}
\def\cT{{\cal T}}
\def\cU{{\cal U}}
\def\cV{{\cal V}}
\def\cW{{\cal W}}
\def\cX{{\cal X}}
\def\cY{{\cal Y}}
\def\cZ{{\cal Z}}
\def\hA{{\hat A}}
\def\hB{{\hat B}}
\def\hC{{\hat C}}
\def\hD{{\hat D}}
\def\hE{{\hat E}}
\def\hF{{\hat F}}
\def\hG{{\hat G}}
\def\hH{{\hat H}}
\def\hI{{\hat I}}
\def\hJ{{\hat J}}
\def\hK{{\hat K}}
\def\hL{{\hat L}}
\def\hP{{\hat P}}
\def\hQ{{\hat Q}}
\def\hR{{\hat R}}
\def\hS{{\hat S}}
\def\hT{{\hat T}}
\def\hX{{\hat X}}
\def\hY{{\hat Y}}
\def\hZ{{\hat Z}}
\def\eps{\epsilon}
\def\C{{\mathcal C}}
\def\F{{\mathcal F}}
\def\A{{\mathcal A}}
\def\H{{\mathcal H}}
\def\bI{\mathbb I}
\def\bO{\mathbb O}
\def\cl{\mathpzc{l}}
\def\overlap{\between}

\def\hd{\hat{\delta}}
\def\Lr{\Leftrightarrow}
\def\If{{\bf if }}
\def\Then{{\bf then }}
\def\Else{{\bf else }}
\def\Do{{\bf do }}
\def\While{{\bf while }}
\def\Continue{{\bf continue }}
\def\Repeat{{\bf repeat }}
\def\Until{{\bf until }}
\def\eqdef{\stackrel {\triangle}{=}}
\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}
\def\cmt{5cm}


%%% new/renew commands
\renewcommand{\algorithmiccomment}[1]
{ 
  \vspace {2mm}
  \hfill ::
  \begin{tabular}{|ll}
   &\parbox{7cm}{ \space \tt{ #1 }}\\  % {\tt /* #1 */}    \hspace{2mm}
  \end{tabular}
}


 % comment in algorithmic
\newtheorem{observation}{Observation}
\newcommand{\Eqr}[1]{Eq.~(\ref{#1})}
\newcommand{\diff}{\ne}
\newcommand{\OO}[1]{O\left( #1\right)}
\newcommand{\OM}[1]{\Omega\left( #1 \right)}
\newcommand{\Prob}[1]{\Pr\left\{ #1 \right\}}
\newcommand{\Set}[1]{\left\{ #1 \right\}}
\newcommand{\Seq}[1]{\left\langle #1 \right\rangle}
\newcommand{\Range}[1]{\left\{1,\ldots, #1 \right\}}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ignore}[1]{}
\newcommand{\eq}{\equiv}
\newcommand{\abs}[1]{\left| #1\right|}
\newcommand{\set}[1]{\left\{ #1\right\}}
\newcommand{\itoj}{{i \rightarrow j}}
\newcommand{\view}{\mbox{$COMM$}}
\newcommand{\pview}{\mbox{$PView$}}
\newcommand{\vx}{\mbox{${\vec x}$}}
\newcommand{\vy}{\mbox{${\vec y}$}}
\newcommand{\vv}{\mbox{${\vec v}$}}
\newcommand{\vw}{\mbox{${\vec w}$}}
\newcommand{\vb}{\mbox{${\vec b}$}}
\newcommand{\basic}{\mbox{\sc Basic}}
\newcommand{\WR}{\mbox{$\lfloor wr \rfloor$}}
\newcommand{\guarantee}{\mbox{\sc BoundedDT}}
\newcommand{\sq}{{\Delta}}
\newcommand{\Smin}{{S_{0}}}
\newcommand{\outt}{{D^{^+}}}
\newcommand{\outtp}{{\overline{D^{^+}}}}
\newcommand{\inn}{{D^{^-}}}
\newcommand{\innp}{{\overline{D^{^-}}}}
\newcommand{\indexx}{{\gamma}}
\newcommand{\D}{{D}}
\newenvironment{denselist}{
  \begin{list}{(\arabic{enumi})}{\usecounter{enumi}
      \setlength{\topsep}{0pt} \setlength{\partopsep}{0pt}
      \setlength{\itemsep}{0pt} }}{\end{list}}
\newenvironment{denseitemize}{
  \begin{list}{$\bullet$}{ \setlength{\topsep}{0pt}
      \setlength{\partopsep}{0pt} \setlength{\itemsep}{0pt}
    }}{\end{list}}
\newenvironment{subdenselist}{
  \begin{list}{(\arabic{enumi}.\arabic{enumii})}{ \usecounter{enumii}
      \setlength{\topsep}{0pt} \setlength{\partopsep}{0pt}
      \setlength{\itemsep}{0pt} }}{\end{list}}

% Review comment. in a parbox that wraps before right margin. vertical
% lines on the left for easy identification.
\newcommand{\rcomment}[1]{}
% { \begin{tabular}{ |||||r| } 
%     \hline
%     \parbox{\cmt}{\tiny{#1}}\\
%     \hline
%   \end{tabular}
% }

\newcommand{\rfootnote}[1] {} %{\footnote{{#1}}}


% D O C U M E N T
\begin{document}
\title{Tree Path Labeling of Path Hypergraphs - A Generalization of the Consecutive Ones Property}
\author{N.S. Narayanaswamy \inst{1} \and Anju Srinivasan \inst{2}}

\institute{ 
  Indian Institute of Technology
  Madras, Chennai, \email{swamy@cse.iitm.ernet.in},\\
  Indian Institute of Technology Madras, Chennai,
  \email{anjuzabil@gmail.com}}


\date{}

\maketitle

\begin{abstract}
  \rcomment{Need to overhaul the abstract}
  We consider the following constraint satisfaction problem: Given a
  set $\cF$ of subsets of a finite set $U$ of cardinality $n$, a tree
  $T$ on $n$ vertices, and an assignment of paths from $T$ to each of
  the subsets, does there exist a bijection $f:U \rightarrow
  \{v_1,\ldots,v_n\}$ such that for each element of $\cF$, its image
  under $f$ is same as the path assigned to it?  A path assignment to
  a given set of subsets is called {\em feasible} if there exists such
  a bijection.  In this paper, we characterize feasible path
  assignments to a given set of subsets and a tree.  This result is a
  natural generalization of results on matrices with the Consecutive
  Ones Property(COP) which can be viewed as a special instance of the
  problem in which the given tree is a path on $n$ vertices.  We also
  present a characterization of set systems and trees which have a
  feasible path assignment.  We also show that testing for a feasible
  path assignment is isomorphism-complete.  On the other hand, it is
  known that if the given tree is a path a feasible assignment can be
  found in polynomial time, and we observe that it can actually be
  done in logspace.
\end{abstract}

\section{Introduction}
%\subsection{Previous Work}
  \rcomment{Needs a section overhaul }
\noindent
Consecutive ones property (COP) of binary matrices is a widely studied
combinatorial problem. The problem is to rearrange rows (columns) of a
binary matrix in such a way that every column (row) has its $1$s occur
consecutively. If this is possible the matrix is said to have the COP.  It
has several practical applications in diverse fields including
scheduling\cite{hl06}, information retrieval\cite{k77} and
computational biology\cite{abh98}.  Further, it is a tool in graph
theory\cite{mcg04} for interval graph recognition, characterization of
hamiltonian graphs, and in integer linear programming\cite{ht02,hl06}.
Recognition of COP is polynomial time solvable by several
algorithms. PQ trees\cite{bl76}, variations of PQ
trees\cite{mm09,wlh01,wlh02,mcc04}, ICPIA\cite{nsnrs09} are the main
ones.
\noindent
The problem of COP testing can be easily seen as a simple constraint
satisfaction problem involving a system of sets from a universe. Every
column of the binary matrix can be converted into a set of integers
which are the indices of the rows with $1$s in that column. When
observed in this context, if the matrix has the COP, a reordering of its
rows will result in sets that have only consecutive integers. In other
words, the sets are intervals. Indeed the problem now becomes finding
interval assignments to the given set system \cite{nsnrs09} with a
single permutation of the universe (set of row indices) which permutes each
set to its interval. The result in \cite{nsnrs09} characterize
interval assignments to the sets which can be obtained from a single
permutation of the rows.  They show that for each set, the interval
cardinality assigned to it must be same as the cardinality of the set,
and the intersection cardinality of any two sets must be same as the
interesction cardinality of the corresponding intervals.  While this
is naturally a necessary condition, it is shown that it is indeed
sufficient.  Such an interval assignment is called an Intersection
Cardinality Preserving Interval Assignment (ICPIA).  The idea of
decomposing a given 0-1 matrix into prime matrices is then taken from
\cite{wlh02} to test if an ICPIA exists for a given set system.

\noindent
{\bf Our Work:}
A natural generalization of the interval assignment problem is
feasible tree path assignments to a set system which is the topic of
this paper. The problem is defined as follows - given a set system
$\cF$ from a universe $U$ and a tree $T$, does there exist a bijection
from the $U$ to the vertices of $T$ such that each set in the system
maps to a path in $T$.  We refer to this as the Tree Path Assignment
problem for an input $(\cF,T)$ pair. As a special case if $T$ is a path
the problem becomes the interval assignment problem.  We focus on the
question of generalizing the notion of an ICPIA \cite{nsnrs09} to
characterize feasible path assignments.  We show that for a given set
system, a tree T, and an assignment of paths from $T$ to the sets,
there is a bijection between $U$ and $V(T)$ if and only if all
intersection cardinalities among any 3 sets (not necessarily distinct)
is same as the intersection cardinality of the paths assigned to them.
This characterization is proved constructively and it gives a natural
data structure that stores all the relevant bijections between $U$ and
$V(T)$.  Further, it also gives an efficient algorithm to test if a
path assignment to the sets is feasible.  This also naturally
generalizes the result in \cite{nsnrs09}.
 
\noindent
It is an interesting fact that for a matrix with the COP, the
intersection graph of the corresponding set system is an interval
graph.  A similar connection to a subclass of chordal graphs, and this
subclass contains interval graphs, exists for the generalization of
COP.  In this case, the intersection graph of the corresponding set
system must be a {\em path graph}. Chordal graphs are of great
significance, extensively studied, and have several applications.  One
of the well known and interesting properties of a chordal graphs is
its connection with intersection graphs\cite{mcg04}. For every chordal
graph, there exists a tree and a family of subtrees of this tree such
that the intersection graph of this family is isomorphic to the
chordal graph\cite{plr70,gav78,bp93}.  Certain format of these trees
are called clique trees\cite{apy92} of the graph which is a compact
representation of the chordal graph. There has also been work done on
the generalization of clique trees to clique hypergraphs\cite{km02}.
If the chordal graph can be represented as the intersection graph of
paths in a tree, then the graph is called path graph\cite{mcg04}.
Therefore, it is clear that if there is a bijection from $U$ to $V(T)$
such that the sets map to paths, then the intersection graph of the
set system is indeed a path graph.  This is, however, only a necessary
condition and can be checked efficiently, as path graph recognition is
polynomial solvable\cite{gav78,aas93}.  Indeed, it is possible to
construct a set system and tree, such that the intersection graph is a
path graph, but there is no bijection between $U$ and $V(T)$ such that
the sets map to paths.  This connection indeed suggests that our
problem is indeed as hard as path graph isomorphism.  Further path
graph isomorphism is known be isomorphism-complete, see for example
\cite{kklv10}.  In the second part of this paper, we decompose our
search for a bijection between $U$ and $V(T)$ into subproblems.  Each
subproblem is on a set system in which for each set, there is another
set in the set system with which the intersection is {\em strict}-
there is a non-empty intersection, but neither is contained in the
other.  This is in the spirit of results in \cite{wlh02,nsnrs09} where
to test for the COP in a given matrix, the COP problem is solved on an
equivalent set of prime matrices.  Our decomposition localizes the
challenge of path graph isomorphism to two problems.

Finally, we show that Tree Path Assignment is isomorphism-complete.
We also point out Consecutive Ones Testing is in Logspace from two
different results in the literature \cite{kklv10, mcc04}. To the best
of our knowledge this observation has not been made earlier.

\noindent {\bf Roadmap:} In Section \ref{prelims} we present the
necessary preliminaries, in Section \ref{feasible} we present our
characterization of feasible tree path assignments, and in Section
\ref{decompos} we present the characterizing subproblems for finding a
bijection between $U$ and $V(T)$ such that sets map to tree
paths. Finally, in Section \ref{complexity} we conclude by showing
that Tree Path Assignment is GI-Complete, and also observe that
Consecutive Ones Testing is in Logspace.
% \noindent
% It has been long known that interval graph recognition is in
% logspace\cite{rei84}. Recently interval graph isomorphism was also
% shown to be logspace decidable using a logspace canonization algorithm
% by \cite{kklv10}. 
% This result is built on top of logspace results of
% undirected graph connectivity \cite{rei08}, logspace tractability
% using a certain logical formalism called FP+C and modular
% decomposition of interval graphs\cite{lau10} etc.
% Interval graphs are closely connected to binary matrices with COP. The
% maximal clique vertex incidence matrix (matrix with rows representing
% maximal cliques and columns representing vertices of a graph) has COP
% on columns iff the graph is an interval graph\cite{fg65}. This follows
% from the interval graph characterization by \cite{gh64}. Due to this
% close relation it is natural to see if consecutive ones property can be
% tested in logspace. \\
% \noindent
% We also explore some extensions of the interval assignment problem in
% \cite{nsnrs09}, namely caterpillar path assignment problem.

% We present a logspace algorithm here that uses the
% ICPIA characterization of binary matrices with COP (set system
% associated with such a matrix)\cite{nsnrs09}.


% \section{Preliminaries}
% A {\em hypergraph} $\cH=(V,E)$  has vertex set $V=\{x_1,x_2, \dots x_n\}$
% and edge set $E \subseteq V$.

% \noindent
% The collection $\F = \{S_i \mid S_i \subseteq U, S_i \ne \O, i \in
% I\}$ is a {\em set system} of a universe $U$.

% \noindent
% Consider a {\em binary matrix} $M$ of order $n \times m$.  The set
% sysetm corresponding to the binary matrix is $\cF_M = \{S_i \mid S_i
% \subseteq U, i \in [m]\}$ where $U = \{x_i \mid i \in [n]\}$ such that
% $x_j \in S_i$ iff $M_{ij} = 1$.

\section{Preliminaries} \label{prelims} 
\noindent
In this paper, the set $\F \subseteq (powerset(U) \setminus \O)$ is a
{\em set system} of a universe $U$ with $|U| = n$. \\

\noindent
The {\em support} of a set system $\F$ denoted by  $supp(\cF)$ is the
union of all the sets in $\F$. Formally, $supp(\F) =
\bigcup_{S \in \F}S$.\\

\noindent
For the purposes of this paper, a set system is required to ``cover'' the universe,
i.e. $ supp(\cF) = U$. \\
% In this paper, the collection $\F = \{S \mid S \subseteq U, S \ne \O
% \}$ \rcomment{wrong. $\F \subseteq $ powerset of $U$} is a {\em set system} of a universe $U$ with $|U| = n$. 
% \
% Moreoever, a set system is assumed to ``cover'' the universe,
% i.e. $ \bigcup_{S \in \cF}S = U$ and the set system is not a multiset
% (for all pairs of sets $S_1, S_2 \in \cF$, $S_1 \ne S_2$). \\


\noindent
To state in simple terms, the {\em intersection graph} $\bI(\cF)$ of a
set system $\cF$ is a graph such that its vertex set has a bijection
to $\cF$ and there exists an edge between two vertices iff their
corresponding sets have a non-empty
intersection (see \cite{mcg04} for more on intersection graphs). \\


\noindent
The graph $T=(V,E)$ represents a given tree with $|V| = n$. 
%Further,
%for simplicity, $V$ is defined as $\{1,\ldots,n\}$. 
All paths
referred to in this paper are paths from $T$ unless explicitly
specified. A {\em path system} $\cP$ is a set system of paths from
$T$. More precisely, $\cP = \{P \mid P \subseteq V, \text{ } T[P]
\text{ is a path.} \}$\\


% \noindent
% A graph $G'$ is called the {\em subdivision} of a graph $G$ if we can
% obtain a graph $H$ from $G$ by replacing any number of edges of $G$ with
% paths by adding any number of new vertices such that $H$ is isomorphic to $G'$.\\

\noindent
A {\em star} graph is a complete bipartite graph
$K_{1,l}$. The vertex with maximum degree is called the {\em center} of
the star and the edges are called {\em rays} of the star.
A {\em $k$-subdivided star} is a star with all its rays subdivided exactly
$k$ times. Thus a $k$-subdivided star has all its rays of length $k+2$.

\noindent
A graph $G$ that is isomorphic to the intersection graph $\bI(\cP)$ of a
path system $\cP$ of $T$, is a {\em path graph}. This
isomorphism $\cl: V(G) \rightarrow \cP$ is called a {\em path
  labeling} of $G$. Moreover, for the purposes of this paper, we
require that in a path labeling, $supp(\cP) = V(T)$. This path system $\cP$ is called a {\em path
representation} of $G$ and may also be denoted by $G^\cl$. If $G =
\bI(\cF)$ where $\cF$ is any set system, then clearly $\cl$ is a
bijection from $\cF$ to $\cP$, $\cl$ is called the
path labeling of set system $\cF$ and the path system $\cP$ may be alternatively
denoted as $\cF^\cl$. \\


\rcomment
{ define hypergraph}

\noindent
A set system $\cF$ can be represented as a hypergraph $\H_\cF$ whose
vertex set is $supp(\cF)$ and hyperedges are sets in $\cF$. This is a
known representation for interval systems in literature (
\rcomment
{*** CITATION ****
BLS99, Section 8.7 from KKLV10).} 
We extend this definition here to path systems.

\noindent
Two hypergraphs $\cH, \cK$ are said to be isomorphic to each other
$\cH \cong \cK$ if there exists a bijection $\phi: supp(\cH)
\rightarrow supp(\cK)$ such that 
for all sets $H \subseteq supp(\cH)$, $H$ is a hyperedge in $\cH$ iff
$K$ is a hyperedge in $\cK$ where $K = \{y \mid y = \phi(x), x \in H\}$.\\


\noindent
If $\H_\cF$ is isomorphic to hypergraph $\H_\cP$ of a path system
$\cP$, then $\H_\cF$ is called a {\em path hypergraph} (of course, 
$\H_\cP$ is trivially a path hypergraph). Then $\cP$
is called {\em path representation} of $\H_\cF$. If isomorphism is
$\phi: supp(\H_\cF) \rightarrow supp(\H_\cP)$, then it is clear that
there is an induced path labeling $l_\phi: \cF \rightarrow \cP$ to the
set system.\\


\rcomment
{Several path labelings could result in the same path representation. EXPAND?}


\noindent
An {\em overlap graph} $\bO(\F)$ of a set system $\cF$ is a graph such
that its vertex set has a bijection to $\cF$ and there exists an edge
between two vertices iff their corresponding sets overlap. Two sets
$A$ and $B$ are said to overlap, denoted by $A \overlap B$, if they
have a non-empty intersection and neither is contained in the other
i.e. $A \overlap B \text{ iff } A \cap B \ne \O, A \nsubseteq B, B
\nsubseteq A$. Thus $\bO(\cF)$ is a subgraph of $\bI(\F)$ and not
necessarily connected. Each connected component of $\bO(\cF)$ is
called an {\em overlap component}. If there are $k$ overlap components
in $\bO(\cF)$, the set subsystems are denoted by $\F_1, \F_2, \ldots
\F_k$. Clearly $\F_i \subseteq \F, i \in [k]$. For any $i, j \in [k]$,
it can be verified that one of the following is true.
\begin{enumerate}
\item[i.] $supp(\F_i)$ and $supp(\F_j)$ are disjoint
\item[ii.] $supp(\F_i)$ is a subset of a set in $\F_j$
\item[iii.] $supp(\F_j)$ is a subset of a set in $\F_i$\\
\end{enumerate}
 

\rcomment
{CHANGE the above for hypergraphs instead of set systems?}

The terms overlap graph and overlap components are analogously defined for
hypergraphs as well. 


% \noindent
% A {\em path assignment} $\A$ to $\F$ is defined as a set assignment
% where second universe is the vertex set $V$ of a given tree $T$ and
% every second subset in the ordered pairs is a path in this tree. Formally, the definition is as follows.
% \begin{align*}
%   \A = \{ (S_i,P_i) \mid  S_i \in \F, P_i \subseteq V \text{ s.t. }T[P_i]
%   \text{ is a path, } i \in I \}
% \end{align*}
% In other words, $P_i$ is the path on the tree $T$ assigned to $S_i$ in
% $\A$. As mentioned before for set systems, the paths cover the whole
% tree, i.e. $\bigcup_{i \in I}P_i = V$ \\




\noindent
% Generalizing the definition of {\em feasibility} in \cite{nsnrs09} to
% a set assignment, a path assignment $\A$ is defined to be {\em
%   feasible} if there exists a bijection defined as follows.
% \begin{align}
%   \sigma: U \rightarrow V(T), \text{ such that }\sigma(S_i) = P_i \text{
%     for all } i \in I, \sigma \text{ is a bijection}
% \label{eq:stf}
% \end{align}
A path labeling $\cl: \cF \rightarrow \cP$ on $\cF$ is defined to be {\em
  feasible} if the hypergraphs $\cH_\cF$ and $\cH_\cP$ are isomorphic
to each other the isomorphism being $\phi: supp(\cF)
\rightarrow supp(\cP)$ and the induced path labeling $\cl_\phi: \cF
\rightarrow \cP$ is
such that $\cl_\phi = \cl$. 

\noindent
Let $X$ be a partially ordered set with $\preccurlyeq$ being the
partial order on $X$.  $mub(X)$ represents an element in $X$ which is
a maximal upper bound on $X$.  $X_m \in X$ is a maximal upper bound of
$X$ if $\nexists X_q \in X$ such that $X_m
\preccurlyeq X_q$. \\

% \noindent
% The set $I$ represents the index set $[m]$. If index $i$ is used
% without further qualification, it is meant to be $i \in I$. Any
% function, if not defined on a domain of sets, when applied on a set is
% understood as the function applied to each of its elements. i.e. for
% any function $f$ defined with domain $U$, the abuse of notation is as
% follows; $f(S)$ is used instead of $\hat f(S)$ where
% $\hat f(S) = \{y \mid y = f(x), x \in S\}$. \\

\noindent
When refering to a tree as $T$ it could be a reference to the tree
itself, or the vertices of the tree. This will be clear from the
context.\\

\noindent
Finally, an in-tree is a directed rooted tree in which all edges are
directed toward to the root.

\section{Characterization of Feasible Tree Path  Labeling} 
\label{feasible} 

Consider a path labeling $\cl: \cF \rightarrow \cP$ for set system $\cF$
and path system $\cP$ on the given tree $T$. We
call $\cl$ an {\em Intersection Cardinality Preserving Path Labeling
  (ICPPL)} if it has the following properties.

\begin{enumerate}
\item [i.]  $|S| = |\cl(S)|$ for all $S \in \cF$
\item [ii.] $|S_1 \cap S_2| = |\cl(S_1) \cap \cl(S_2)|$ for all
  distinct $S_1, S_2 \in \cF$
\item [iii.] $|S_1 \cap S_2 \cap S_3| = |\cl(S_1) \cap \cl(S_2) \cap
  \cl(S_3)|$ for all distinct  $S_1, S_2, S_3 \in \cF$
\end{enumerate}


% \begin{lemma}
%   \label{lem:setminuscard}
%   If $\cA$ is an ICPPA, and $(S_1, P_1),(S_2, P_2),(S_3, P_3) \in
%   \cA$, then $|S_1 \cap (S_2 \setminus S_3)| = |P_1 \cap (P_2
%   \setminus P_3)|$.
% \end{lemma}
% \begin{proof}
%   $|S_1 \cap (S_2 \setminus S_3)| = |(S_1 \cap S_2) \setminus S_3| =
%   |S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3|$. Due to conditions (ii)
%   and (iii) of ICPPA, $|S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3| = |P_1
%   \cap P_2| - |P_1 \cap P_2 \cap P_3| = |(P_1 \cap P_2) \setminus P_3|
%   = |P_1 \cap (P_2 \setminus P_3)|$. Thus lemma is proven. \qed
% \end{proof}

\begin{lemma}
  \label{lem:setminuscard}
  If $\cl$ is an ICPPL, and $S_1, S_2, S_3 \in
  \cF$, then $|S_1 \cap (S_2 \setminus S_3)| = |P_1 \cap (P_2
   \setminus P_3)|$ where $P_i = \cl(S_i), i \in \{1, 2, 3\}$.
\end{lemma}
\begin{proof}
  $|S_1 \cap (S_2 \setminus S_3)| = |(S_1 \cap S_2) \setminus S_3| =
  |S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3|$. Due to conditions (ii)
  and (iii) of ICPPL, $|S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3| = |P_1
  \cap P_2| - |P_1 \cap P_2 \cap P_3| = |(P_1 \cap P_2) \setminus P_3|
  = |P_1 \cap (P_2 \setminus P_3)|$. Thus lemma is proven. \qed
\end{proof}

\begin{lemma}
  \label{lem:fourpaths} Consider four paths in a tree $P_1, P_2, P_3,
  P_4$ such that they have non-empty pairwise intersection and paths $P_1,
  P_2$ share a leaf. Then there exists distinct $i, j, k \in
  \{1,2,3,4\}$ such that, $P_1 \cap P_2 \cap P_3 \cap P_4 = P_i \cap
  P_j \cap P_k$.
\end{lemma}
\begin{proof}
  {\em Case 1:} Consider the path $P = P_3 \cap P_4$ (intersection of
  two paths is a path).
  % Since $P_1, P_2$ share a leaf, the following are paths $P_1
  % \setminus P_2$, $P_2 \setminus P_1$, $P_1 \cap P_2$ and they are
  % mutually disjoint.
  Suppose in this case, $P$ does not intersect with $P_1 \setminus
  P_2$, i.e. $P \cap (P_1 \setminus P_2) = \O$. Then $P \cap P_1 \cap
  P_2 = P \cap P_2$. Similarly, if $P \cap (P_2 \setminus P_1) = \O$,
  $P \cap P_1 \cap P_2 = P \cap P_1$. Thus it is clear that if the
  intersection of any two paths does not intersect with any of the set
  differences of
  the remaining two paths, the claim in the lemma is true.\\
  {\em Case 2:} The other possibilty is the compliment of the previous
  case which is as follows. So let us assume that the intersection of
  any two paths intersects with both the set differences of the other
  two. First let us consider $P \cap (P_1 \setminus P_2) \ne \O$ and
  $P \cap (P_2 \setminus P_1) \ne \O$, where $P = P_3 \cap P_4$. Since
  $P_1$ and $P_2$ share a leaf, there is exactly one vertex at which
  they branch off from the path $P_1 \cap P_2$ into two paths $P_1
  \setminus P_2$ and $P_2 \setminus P_1$. Let this vertex be $v$. It
  is clear that if path $P_3 \cap P_4$, must intersect with paths $P_1
  \setminus P_2$ and $P_2 \setminus P_1$, it must contain $v$ since
  these are paths from a tree. Moreover, $P_3 \cap P_4$ intersects
  with $P_1 \cap P_2$ at exactly $v$ and only at $v$ which means that
  $P_1 \cap P_2$ does not intersect with $P_3 \setminus P_4$ or $P_4
  \setminus P_3$ which contradicts the assumption of this case. Thus
  this  case cannot occur and case 1 is the only possible scenario. \\
  Thus lemma is proven. \qed
\end{proof}


\noindent
In the remaining part of this section we show that a path labeling is
feasible if and only if it is an ICPPL.  One direction of this claim
is clear: that if a path labeling is feasible, then all intersection
cardinalities are preserved, i.e. the path labeling is an ICPPL.  The
reason is that a feasible path labeling has an associated bijection
between $supp(\cF)$ and $V(T)$ such that the sets map to paths. The
rest of the section is devoted to constructively proving that it is
sufficient, for a path labeling to be an ICPPL.  At a top-level, the
constructive approaches refine the path labeling iteratively, such
that at the end of each iteration we have a ``filtered'' path labeling,
and finally we have a path labeling that defines a family of
bijections from $supp(\cF)$ or $U$ to $supp(\cP)$ or $V(T)$.  First we
present and then prove the correctness of Algorithm \ref{perms}.  This
algorithm refines the path labeling by considering pairs of paths that
share a leaf.

% \begin{algorithm}[h]
% \caption{Refine ICPPA ($S_i, P_i$)}
% \label{perms}
% \begin{algorithmic}
% \STATE Let $\Pi_0=\{(S_i,P_i)| i \in I\}$\\
% \STATE $j = 1$;
% \label{shareleaf} \WHILE {There is $(P_1,Q_1), (P_2,Q_2) \in \Pi_{j-1}$ with $Q_1$ and
%   $Q_2$ having a common leaf}
% \STATE $\Pi_j=   \Pi_{j-1} \setminus \{(P_1,Q_1),(P_2,Q_2)\}$;
% \label{setbreak}\STATE $\Pi_j = \Pi_j \cup \{(P_1 \cap P_2,Q_1 \cap Q_2), (P_1 \setminus P_2,Q_1 \setminus Q_2), (P_2 \setminus P_1, Q_2 \setminus Q_1)\}$;
% \STATE $j = j+1$;
% \ENDWHILE
% \STATE $\Pi = \Pi_j$;
% \STATE Return $\Pi$;
% \end{algorithmic}
% \end{algorithm}

\begin{algorithm}[h]
\caption{Refine ICPPL ($\cF$, $\cl$)}
\label{perms}
\begin{algorithmic}
\STATE Let $\cF_0 = \cF$\\
\STATE Let $\cl_0(S) = \cl(S)$ for all $S \in \cF_0$\\
\STATE $j = 1$\\
\label{shareleaf} \WHILE {there is $S_1, S_2 \in \cF_{j-1}$ such that $\cl_{j-1}(S_1)$ and
  $\cl_{j-1}(S_2)$ have a common leaf in $T$}
\label{setbreak} \STATE $\cF_j = (\cF_{j-1} \setminus \{S_1, S_2\}) \cup \{S_1 \cap S_2, S_1 \setminus S_2, S_2
\setminus S_1 \}$\\
\STATE for all $S \in \cF_{j-1}$ such that $S \ne S_1$ and $S \ne
S_2$, set $\cl_j(S) = \cl_{j-1}(S)$\\
\STATE $\cl_j(S_1 \cap S_2) = \cl_{j-1}(S_1) \cap \cl_{j-1}(S_2)$
\STATE $\cl_j(S_1 \setminus S_2) = \cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)$
\STATE $\cl_j(S_2 \setminus S_1) = \cl_{j-1}(S_2) \setminus \cl_{j-1}(S_1)$

%\Pi_j \cup \{(P_1 \cap P_2,Q_1 \cap Q_2), (P_1 \setminus P_2,Q_1 \setminus Q_2), (P_2 \setminus P_1, Q_2 \setminus Q_1)\}$;
\STATE $j = j+1$\\
\ENDWHILE
\STATE $\cF' = \cF_j$, $\cl' = \cl_j$\\
\STATE Return $\cF', \cl'$\\
\end{algorithmic}
\end{algorithm}




% \begin{lemma}
% \label{lem:invar1}
%   In Algorithm \ref{perms}, at the end of $j$th iteration, $j \ge 0$, of the while loop of 
%   Algorithm \ref{perms}, the following invariants are maintained.
% \begin{itemize}
% \item {\em Invariant I:} $Q$ is a path in $T$ for each $(P,Q) \in
%   \Pi_j$
% \item {\em Invariant II:} $|P|=|Q|$ for each $(P,Q) \in \Pi_j$
% \item {\em Invariant III:} For any two $(P,Q), (P',Q') \in \Pi_j$,
%   $|P' \cap P''|=|Q' \cap Q''|$. 
% \item {\em Invariant IV:} For any three, $(P',Q'), (P'',Q''),
%   (P, Q) \in \Pi_j$,
%   $|P' \cap P'' \cap P|=|Q' \cap Q'' \cap Q|$.
% \end{itemize}
% \end{lemma}
% \begin{proof}
%   Proof is by induction on the number of iterations, $j$. In the rest
%   of the proof, the term ``new sets'' will refer to the new sets added
%   in $j$th iteration as defined in line \ref{setbreak} of Algorithm
%   \ref{perms}, i.e. the following three assignment pairs for
%   some $(P_1,Q_1), (P_2,Q_2) \in \Pi_{j-1}$ where $Q_1$ and $Q_2$
%   intersect and share a leaf: $(P_1 \cap P_2, Q_1 \cap Q_2)$, or $(P_1
%   \setminus P_2, Q_1 \setminus Q_2)$, or $(P_2 \setminus P_1, Q_2
%   \setminus Q_1)$.\\
%   \noindent
%   The base
%   case, $\Pi_0 = \{(S_i,P_i) \mid i \in [m]\}$, is trivially true since it
%   is the input which is an ICPPA.  Assume the lemma is true till the $j-1$
%   iteration. Consider $j$th
%   iteration:\\
%   \noindent
%   If $(P,Q)$, $(P',Q')$ and $(P'',Q'')$ are in $\Pi_{j}$ and
%   $\Pi_{j-1}$, all the invariants are
%   clearly true because they are from $j-1$ iteration.\\
%   If $(P,Q)$ is in $\Pi_{j}$ and not in $\Pi_{j-1}$, then it must be
%   one of the new sets added in $\Pi_j$. Since $(P_1,Q_1)$ and
%   $(P_2,Q_2)$ are from $\Pi_{j-1}$ and $Q_1,Q_2$ intersect and have a
%   common leaf, it can be verified that the
%   new sets are also paths. \\
%   By hypothesis for invariant III, invariant II also holds for $(P,Q)$
%   no matter which new set in $\Pi_j$ it
%   is.\\
%   To prove invariant III, if $(P,Q)$ and $(P',Q')$ are not in
%   $\Pi_{j-1}$, then they are both new sets and invariant III holds
%   trivially (new sets are disjoint). Next consider $(P,Q), (P',Q') \in
%   \Pi_j$ with only one of them, say $(P',Q')$, in $\Pi_{j-1}$. Then
%   $(P,Q)$ is one of the new sets added in line \ref{setbreak}. It is
%   easy to see that if $(P,Q)$ is $(P_1 \cap P_2, Q_1 \cap Q_2)$, then
%   due to invariant IV in hypothesis, invariant III becomes true in
%   this iteration. Similarly, using lemma \ref{lem:setminuscard}
%   invariant III is proven if $(P, Q)$ is $(P_1 \setminus P_2, Q_1
%   \setminus Q_2)$, or $(P_2 \setminus P_1, Q_2
%   \setminus Q_1)$.\\
%   To prove invariant IV, consider three assignments
%   $(P,Q),(P',Q'),(P'',Q'')$. If at least two of these pairs are in not
%   $\Pi_{j-1}$, then they are any two of the new sets. Note that these
%   new sets are disjoint and hence if $(P',Q'), (P'',Q'')$ are any of
%   these sets, $|P \cap P' \cap P''|=|Q \cap Q' \cap Q''|=0$ and
%   invariant IV is true. Now we consider the case if at most one of
%   $(P,Q),(P',Q'),(P'',Q'')$ is not in $\Pi_{j-1}$. If none of them are
%   not in $\Pi_{j-1}$ (i.e. all of them are in $\Pi_{j-1}$), invariant
%   IV is clearly true. Consider the case where exactly one of them is
%   not in $\Pi_{j-1}$. w.l.o.g let that be $(P,Q)$ and it could be any
%   one of the new sets. If $(P,Q)$ is $(P_1 \cap P_2, Q_1 \cap Q_2)$,
%   from lemma \ref{lem:fourpaths} and invariant III hypothesis,
%   invariant IV is proven. Similarly if $(P,Q)$ is any of the other new
%   sets, invariant IV is proven by also using lemma
%   \ref{lem:setminuscard}. \qed

% \end{proof}


\begin{lemma}
\label{lem:invar1}
  In Algorithm \ref{perms}, at the end of $j$th iteration, $j \ge 0$, of the while loop of 
  Algorithm \ref{perms}, the following invariants are maintained.
\begin{itemize}
\item {\em Invariant I:} $\cl_j(R)$ is a path in $T$ for each $R \in \cF_j$
\item {\em Invariant II:} $|R| = |\cl_j(R)|$ for each $R \in \cF_j$
\item {\em Invariant III:} For any two $R, R' \in \cF_j$,
  $|R \cap R'| = |\cl_j(R) \cap \cl_j(R')|$
\item {\em Invariant IV:} For any three, $R, R', R'' \in \cF_j$,
  $|R \cap R' \cap R''|=|\cl_j(R) \cap \cl_j(R') \cap \cl_j(R'')|$
\end{itemize}
\end{lemma}
%\label{lem:invar1}
\begin{proof}
  Proof is by induction on the number of iterations, $j$. In the rest
  of the proof, the term ``new sets'' will refer to the sets added
  to $\cF_j$ in $j$th iteration in line \ref{setbreak} of Algorithm
  \ref{perms}, $\{S_1 \cap S_2, S_1 \setminus S_2, S_2 \setminus S_1
  \}$ and its images in $\cl_j$ where $\cl_{j-1}(S_1)$ and
  $\cl_{j-1}(S_2)$
  intersect and share a leaf.\\
  \noindent
  The base case, $\cl_0$ is an ICPPL on $\cF_0$, since it is the
  input.  Assume the lemma is true till the $j-1$ iteration. Let us consider
the possible cases for each invariant for the  $j$th  iteration.

  \noindent
  \begin{enumerate}
  \item [Case 1:] {\em Invariant I and II} 
    \begin{enumerate}
    \item [Case 1.1:] {\em $R$ is not a new set.} If $R$ is in
      $\cF_{j-1}$, then by induction hypothesis this case is trivially
      proven.
    \item [Case 1.2:] {\em $R$ is a new set.} If $R$ is in $\cF_{j}$
      and not in $\cF_{j-1}$, then it must be one of the new sets
      added in $\cF_j$. In this case, it can be easily verified that
      all the new sets are also paths since by definition the chosen
      sets $S_1$ and $S_1$ are from $\cF_{j-1}$ and by the while loop
      condition, $\cl_{j-1}(S_1), \cl_{j-1}(S_2)$ have a common
      leaf. Thus invariant I is proven.\\
      Moreover, due to induction hypothesis of invariant III ($j-1$th
      iteration), invariant II can be verified easily for $j$th
      iteration by using the definition of $l_j$ in terms of $l_{j-1}$
      for any of the new sets.
   \end{enumerate}
  \item [Case 2:] {\em Invariant III}
    \begin{enumerate}
    \item [Case 2.1:] {\em $R$ and $R'$ are not new sets.} Trivially
      true by induction hypothesis.
    \item [Case 2.2:] {\em Only one, say $R$, is a new set.} Due to
      induction IV hypothesis, lemma \ref{lem:setminuscard} and
      definition of $l_j$ with the fact that $R'$ is not a new set, it
      can be verified that invariant III is true no matter which of
      the new sets $R$ is equal to.
    \item [Case 2.3:] {\em $R$ and $R'$ are new sets.} By definition,
      the new sets and their path images in path label $l_j$ are
      disjoint so $|R \cap R'| = |l_j(R) \cap l_j(R)| = 0$. Thus case
      proven.
    \end{enumerate}
  \item [Case 3:] {\em Invariant IV}
    \begin{enumerate}
    \item [Case 3.1:] {\em $R$, $R'$ and $R''$ are not new sets.} Trivially
      true by induction hypothesis.
    \item [Case 3.2:] {\em Only one, say $R$, is a new set.}
      ******** PROOF NOT CLEAR TBD ******* \\
      Consider the case where exactly one of them is
      not in $\Pi_{j-1}$. w.l.o.g let that be $(P,Q)$ and it could be any
  one of the new sets. If $(P,Q)$ is $(P_1 \cap P_2, Q_1 \cap Q_2)$,
  from lemma \ref{lem:fourpaths} and invariant III hypothesis,
  invariant IV is proven. Similarly if $(P,Q)$ is any of the other new
  sets, invariant IV is proven by also using lemma
  \ref{lem:setminuscard}.\\
  ******** END PROOF NOT CLEAR TBD ******* 

    \item [Case 3.3:] {\em At least two of $R, R', R''$ are new sets.}
      The new sets are disjoint hence this case is vacuously true.
    \end{enumerate}
  \end{enumerate} \qed

\end{proof}



\noindent
% It can be observed that the output of algorithm \ref{perms} is such
% that every leaf is incident on at most a single path in the path images of
% the returned set system $\cF'$ on the returned path labeling $\cl'$. This is due to the loop condition at line
% \ref{shareleaf}. Let $v$ be the leaf incident on path $P$. 
% Then we define $\cl^{-1}(\{v\}) = \{x\}$
% where $x$ any one element from $S_i \setminus \bigcup_{i \ne j}
% S_j$. Remove $(S_i, P_i)$ from assignments and add $(\{x_1\},
% \{v_1\}), (S_i \setminus \{x_1\}, P_i \setminus \{v_1\})$. Now all
% assignments except single leaf assignments are paths from the subtree
% $T_0 = T \setminus \{v \mid v \text{ is a leaf in } T\}$. This is the
% function of Algorithm \ref{leafasgn}.

\noindent
It can be observed that the output of algorithm \ref{perms} is such
that every leaf of $T$ is incident on at most one path in the path
images of the returned set system $\cF$ on the returned path labeling
$\cl$. This is due to the loop condition at line \ref{shareleaf}. The
next algorithm refines the path labeling and the set system further as
follows. This is done to help reduce the size of the problem by
pruning the tree off its leaves.  Let vertex $v \in T$ be the unique
leaf incident on a path image $P$ in $\cl$.  We define a new path
labeling $\cl_{new}$ such that $\cl_{new}(\{x\}) = \{v\}$ where $x$ an
arbitrary element from $\cl^{-1}(P) \setminus \bigcup_{\hP \ne P}
\cl^{-1}(\hP)$. In other words, $x$ is an element present in no other
set in $\cF$ except $\cl^{-1}(P)$. This is intuitive since $v$ is
present in no other path image other than $P$.  The element $x$ and
leaf $v$ are then removed from the set $\cl^{-1}(P)$ and path $P$
respectively. The tree is pruned off $v$ and the refined set system
will have $\cl^{-1}(P) \setminus \{x\}$. After doing this for all
leaves in $T$ (that is part of a path image), all path images in the
new path labeling $\cl_{new}$ except single leaf labels (the pruned
out vertex is called the {\em leaf label} for the corresponding set
item) 
are paths from the pruned
tree $T_0 = T \setminus \{v \mid v \text{ is a leaf in }
T\}$. Algorithm \ref{leafasgn} is now presented with details.


\begin{algorithm}[h]
\caption{Leaf labeling from an ICPPL $(\cF,\cl)$}
\label{leafasgn}
\begin{algorithmic}
\STATE Let $\cF_0 = \cF$\\
\STATE Let $\cl_0(S) = \cl(S)$ for all $S \in \cF_0$. Note: Path images are such that no
two path images share a leaf.\\
\STATE $j = 1$\\
\label{uniqueleaf}\WHILE {there is a leaf $v$ in $T$ and a unique $S_1 \in \cF_{j-1}$ such that
  $v \in \cl_{j-1}(S_1)$ }
\STATE $\cF_j = \cF_{j-1} \setminus \{S_1\}$\\
\STATE for all $S \in \cF_{j-1}$ such that $S \ne S_1$ set $\cl_j(S) =
\cl_{j-1}(S)$\\
\STATE $X = S_1 \setminus \bigcup_{S \in \cF_{j-1}, S \ne S_1}S$\\
\IF{$X$ is empty} 
\STATE exit \\
\ENDIF
\STATE Let $x = $ arbitrary element from $X$\\
\STATE $\cF_j = \cF_j \cup \{\{x\}, S_1 \setminus \{x\}\} $\\
\STATE $\cl_j(\{x\}) = \{v\}$\\
\STATE $\cl_j(S_1 \setminus \{x\}) = \cl_{j-1}(S_1) \setminus \{v\}$\\
\STATE $j = j+1$\\
\ENDWHILE
\STATE $\cF' = \cF_j$\\
\STATE $\cl' = \cl_j$\\
\STATE Return $\cF', \cl'$\\
\end{algorithmic}
\end{algorithm}

\begin{lemma}
\label{lem:invar3}
In Algorithm \ref{leafasgn}, for all $j \geq 0$, at the end of the
$j$th iteration the four invariants given in lemma \ref{lem:invar1}
are valid.  
\end{lemma}
\begin{proof}
  First we see that $X = S_1 \setminus \bigcup_{S \ne S_1}S$ is
  non-empty for an ICPPL in every iteration of this algorithm. Suppose
  $X$ is empty. We know that $v$ is an element of
  $\cl_{j-1}(S_1)$. Since it is uniquely present in $\cl_{j-1}(S_1)$,
  it is clear that $v \in \cl_{j-1}(S_1) \setminus \bigcup_{S \in
    \cF_{j-1}, S \ne S_1}\cl_{j-1}(S)$.  Note that for any $x \in S_1$
  it is contained in at least two sets due to our assumption about
  cardinality of $X$. Let $S_2 \in \cF_{j-1}$ be another set that
  contains $x$. From the above argument, we know $v \notin
  \cl_{j-1}(S_2)$. ******** NOT CLEAR TBD ******* Therefore there cannot exist a
  permutation that maps elements of $S_{i_2}$ to $P_{i_2}$. This
  contradicts our assumption that this is an ICPPA. Thus $X$ cannot be
  empty. ******** END NOT CLEAR TBD *******

  \noindent
  For the rest of the proof we use mathematical induction on the
  number of iterations $j$. As before, the term ``new sets'' will
  refer to the sets added in $\cF_j$ in the $j$th iteration, i.e. $S_1
  \setminus \{x\}$ and $\{x\}$ as defined in line \ref{uniqueleaf}.\\
  For $\cF_0, \cl_0$ all invariants hold because it is output from
  algorithm \ref{perms} which is an ICPPL. Hence base case is proved.
  Assume the lemma holds for the $j-1$th iteration. Consider $j$th
  iteration 
%and any $(P,Q) \in \Pi_j$.

  \noindent
  \begin{enumerate}
  \item [Case 1:] {\em Invariant I and II} 
    \begin{enumerate}
    \item [Case 1.1:] {\em $R$ is not a new set.} If $R$ is in
      $\cF_{j-1}$, then by induction hypothesis this case is trivially
      proven.
    \item [Case 1.2:] {\em $R$ is a new set.} If $R$ is in $\cF_{j}$
      and not in $\cF_{j-1}$, then it must be one of the new sets
      added in $\cF_j$. Removing a leaf $v$ from path $\cl_{j-1}(S_1)$
      results in another path. Moreover, $\{v\}$ is trivially a
      path. Hence regardless of which new set $R$ is, by definition of
      $\cl_j$, $\cl_{j}(R)$ is a path. Thus invariant I is proven.\\
      We know $|S_1| = |\cl_{j-1}(S_1)|$, due to induction
      hypothesis. Therefore $|S_1 \setminus \{x\}| = |\cl_{j-1}(S_1)
      \setminus \{v\}|$. This is because $x \in S_1$ iff $v \in
      \cl_{j-1}(S_1)$. If $R = \{x\}$, invariant II is trivially
      true. Thus invariant II is proven.
  \end{enumerate}
  \item [Case 2:] {\em Invariant III}
    \begin{enumerate}
    \item [Case 2.1:] {\em $R$ and $R'$ are not new sets.} Trivially
      true by induction hypothesis.
    \item [Case 2.2:] {\em Only one, say $R$, is a new set.} 
  By definition, $\cl_{j-1}(S_1)$ is the only path with $v$ and $S_1$ the
  only set with $x$ in the
  previous iteration, hence $|R' \cap (S_1 \setminus \{x\})| = |R' \cap S_1|$
  and $|\cl_{j-1}(R') \cap (\cl_{j-1}(S_1) \setminus \{v\})| = |\cl_{j-1}(R') \cap \cl_{j-1}(S_1)|$ and $|R' \cap
  \{x\}| = 0$, $|\cl_{j-1}(R') \cap \{v\}| = 0$. Thus case proven.
    \item [Case 2.3:] {\em $R$ and $R'$ are new sets.} By definition,
      the new sets and their path images in path label $l_j$ are
      disjoint so $|R \cap R'| = |l_j(R) \cap l_j(R)| = 0$. Thus case
      proven.
    \end{enumerate}
  \item [Case 3:] {\em Invariant IV}
    \begin{enumerate}
    \item [Case 3.1:] {\em $R$, $R'$ and $R''$ are not new sets.} Trivially
      true by induction hypothesis.
    \item [Case 3.2:] {\em Only one, say $R$, is a new set.}
      ******** PROOF NOT CLEAR TBD *******\\  
      If exactly one of them, say $P_3 \notin \Pi_{j-1}$, it is one of the new sets. By the same argument used to
  prove invariant III, $|P_1 \cap P_2 \cap (P'
  \setminus \{x\})| = |P_1 \cap P_2 \cap P'|$ 
  and $|Q_1 \cap Q_2 \cap (Q' \setminus \{x\})| = |Q_1 \cap Q_2 \cap
  Q'|$. Since $P_1, P_2, P'$ are all in $\Pi_{j-1}$, by induction hypothesis
  $|P_1 \cap P_2 \cap P'| = |Q_1 \cap Q_2 \cap Q'|$. Also $|P_1 \cap
  P_2 \cap \{x\}| = 0, Q_1 \cap Q_2 \cap \{v\} = 0$. \\
  ******** END PROOF NOT CLEAR TBD *******


    \item [Case 3.3:] {\em At least two of $R, R', R''$ are new sets.}
      ******** PROOF NOT CLEAR TBD *******\\
      If two or more of them are not in $\Pi_{j-1}$, then it can
  be verified that $|P_1
  \cap P_2 \cap P_3| = |Q_1 \cap Q_2 \cap Q_3|$ since the new sets
  in $\Pi_j$ are either disjoint or as follows: assuming $P_1, P_2
  \notin \Pi_{j-1}$ and new sets are derived from $(P', Q'), (P'', Q'') \in
  \Pi_{j-1}$ with $x_1, x_2$
  exclusively in $P_1, P_2$, $(\{x_1\},\{v_1\}), (\{x_2\},\{v_2\})
  \in \Pi_j $ thus $v_1, v_2$ are exclusively in $Q_1, Q_2$ resp. it
  follows that
$|P_1
  \cap P_2 \cap P_3| = |(P' \setminus \{x_1\}) \cap (P'' \setminus
  \{x_2\}) \cap P_3| = |P' \cap P'' \cap P_3| = |Q' \cap Q'' \cap Q_3|
  = |(Q' \setminus \{v_1\} \cap Q'' \setminus \{v_2\} \cap Q_3| =
  |Q_1 \cap Q_2 \cap Q_3|$. Thus invariant
  IV is also proven.\\
  ******** END PROOF NOT CLEAR TBD *******
    \end{enumerate}
  \end{enumerate} \qed
\end{proof}

\noindent
Using algorithms \ref{perms} and \ref{leafasgn} we prove the following
theorem.\\\\
******** NOT IN NEW NOTATION TBD *******
\begin{theorem}
\label{th:perm}
  If $\cF$ has an ICPPL $\cl$, then there exists a hypergraph
  isomorphism $\sigma : \cH_\cF \rightarrow \cH$ such that $\sigma(S_i) = P_i$ for all $i \in I$
\end{theorem}
\begin{proof}
This is a contructive proof. First, the given ICPPA $\cA$ and tree $T$ are given as input to Algorithm
\ref{perms}. This yields a ``filtered'' ICPPA as the output which is
input to Algorithm \ref{leafasgn}.
It can be observed that the output of Algorithm \ref{leafasgn} is a set of path
assignments to sets and one-to-one assignment of elements of $U$ to
each leaf of $T$. To be precise, it would be of the form $\cB_0 =
\cA_0 \cup \cL_0$. The leaf assignments are defined in $\cL_0
= \{ (x_i,v_i) \mid x_i \in U, v_i \in T, x_i \ne x_j, v_i \ne v_j, i \ne j, i,j \in [k] \}$ where $k$ is the
number of leaves in $T$. The path assignments are defined in $\cA_0
\subseteq \{(S_i',P_i') \mid S_i' \subseteq U_0, P_i' \text{ is a path
  from } T_0\}$ where $T_0$ is the tree obtained by removing all the
leaves in $T$ and $U_0 = U \setminus \{ x \mid x \text{ is assigned to
  a leaf in }\cL_0 \}$. Now we have a subproblem of finding the
permutation for the path assignment $\cA_0$ which has paths from tree
$T_0$ and sets from universe $U_0$. Now we repeat the procedure and the path assignment $\cA_0$ and tree $T_0$
is given as input to Algorithm \ref{perms}. The output of this
algorithm is given to Algorithm \ref{leafasgn} to get a new
union of path and leaf assignments $\cB_1 =
\cA_1 \cup \cL_1$ defined similar to $\cB_0, \cL_0, \cA_0$. In
general, the two algorithms are run on
path assignment $\cA_{i-1}$ with paths from tree $T_{i-1}$ to get a new
subproblem with path assignment $\cA_i$ and tree $T_{i}$. $T_i$ is
the subtree of $T_{i-1}$ obtained by removing all its leaves. More importantly, it gives leaf
assignments $\cL_{i}$ to the leaves in tree $T_{i-1}$. This is
continued until we get a subproblem with path assignment $\cA_{d-1}$ and
tree $T_{d-1}$ for some $d \le n$ which is just a
path. From the last lemma we know that $\cA_{d-1}$ is an
ICPPA. Another observation is that an ICPPA with all its tree paths
being intervals (subpaths from a path) is nothing but an ICPIA\cite{nsnrs09}.
Let $\cA_{d-1}$ be equal to $\{(S_i'',P_i'') \mid S_i'' \subseteq U_{d-1}, P_i'' \text{ is a path
  from } T_{d-1} \}$. It is true that the paths $P_i''$s
may not be precisely an interval in the sense of consecutive integers
because they are some nodes from a tree. However, it is easy to see that
the nodes of $T_{d-1}$ can be ordered from left to right and ranked to get
intervals $I_i$ for every path $P_i''$ as follows. $I_i = \{[l,r]
\mid l = \text{ the lowest rank of the nodes in }P_i'', r = l+|P_i''|-1
\}$. Let asssignment $\cA_d$ be with the renamed paths. $\cA_d = \{ (S_i'', I_i) \mid (S_i'', P_i'') \in \cA_{d-1}
\}$. What has been effectively done is renaming the nodes in $T_{d-1}$
to get a tree $T_d$.
The ICPIA $\cA_d$ is now in the format that the ICPIA algorithm
requires which gives us the permutation $\sigma' : U_{d-1} \rightarrow T_{d-1}$

\noindent
$\sigma'$ along with all the leaf assignments $\cL_i$
gives us the permutation for the original path assignment $\cA$.
More precisely, the permutation for tree path assignment $\cA$ is defined as
follows. $\sigma: U \rightarrow T$ such that the following
is maintained.
\begin{align*}
 \sigma(x) &= \sigma'(x),   \text{ if } x \in U_{d-1} \\
           &= \cL_i(x),     \text{ where $x$ is assigned to a leaf in a
             subproblem $\cA_{i-1}, T_{i-1}$}
\end{align*}

\noindent
To summarize, run algorithm \ref{perms} and
\ref{leafasgn} on $T$. After the leaves have been assigned to specific
elements from $U$, remove all leaves from $T$ to get new tree
$T_0$. The leaf assignments are in $\cL_0$. Since only leaves were removed $T_0$ is indeed a tree. Repeat
the algorithms on $T_0$ to get leaf assignments $\cL_{1}$. Remove the
leaves in $T_0$ to get $T_1$ and so on until the pruned tree $T_d$
is a single path. Now run ICPIA algorithm on $T_d$ to get
permutation $\sigma'$. The relation $\cL_0 \cup \cL_1 \cup .. \cup
\cL_{d} \cup \sigma'$ gives the bijection required in the original problem.\qed
\end{proof}
******** END NOT IN NEW NOTATION TBD *******

\section{Finding an assignment of tree paths to a set
  system} \label{sec:decompos} 
In the previous section we have shown that
the problem of finding a Tree Path Labeling to an input $(\cF,T)$
is equivalent to finding an ICPPL to $\cF$ in tree $T$.  In this
section we characterize those set systems that have an ICPPL in a
given tree.  As a consequence of this characterization we identify two
sub-problems that must be solved to obtain an ICPPL.  We do not solve
these subproblems but use them as blackboxes to describe the rest of
the algorithm. In the next section, we solve one of these subproblems
for a smaller class of trees, $k$-subdivided stars.

\noindent
A set system can be concisely represented by a binary matrix where the
row indices denote the universe of the set system and the column
indices denote each of the sets. Let the binary matrix be $M$ with
order $n \times m$, the set system be $\cF = \{S_i \mid i \in [m]\}$,
universe of set system $U = \{x_i \mid i \in [n]\}$. We say $M$ represents
$\cF$, if $(i,j)$th element of $M$, $M_{ij} =
1$ iff $x_i \in S_j$. If $\cF$ has a feasible tree path labeling $\cl:
\cF \rightarrow \cP$, where $\cP$ is a set of paths from a given tree
$T$
% with vertex set $V(T) = \{ v_i \mid i \in [n] \}$
%$\cA = \{(S_i,P_i) \mid i \in [m]\}$, 
then we say its 
corresponding matrix $M$ has an ICPPL. Since $\cl$ is feasible, there
exists a bijection $\phi: [n] \rightarrow [n]$ such that $\cl(S_i) =
\{v_j \mid j \in \{ \phi(x) \mid x \in S_i\} \}$.

Conversely, we say that a matrix
$M$ has an ICPPL if there exists an ICPPL $\cl$ as defined
above.

\noindent
We now define the strict intersection graph or overlap graph of
$\cF$. This graph occurs at many places in the literature, see for
example \cite{kklv10, wlh02, nsnrs09}. The vertices of the graph
correspond to the sets in $\cF$.  An edge is present between vertices
of two sets iff the corresponding sets have a nonempty intersection
and none is contained in the other. Formally, strict intersection graph is
$G_f = (V_f, E_f)$ such that $V_f = \{v_i \mid S_i \in \cF\}$ and $E_f
= \{(v_i, v_j) \mid S_i \cap S_j \ne \O \text{ and }S_i \nsubseteq
S_j, S_j \nsubseteq S_i \}$.  The usage of overlap graph to
decompose the problem of consecutive ones testing was first introduced
by \cite{fg65}. They showed that a binary matrix or its corresponding
set system has the COP iff each connected component of the overlap
graph (the sets corresponding to this component or its corresponding
submatrix) has the COP. The same approach is also described in
\cite{wlh02,nsnrs09}. We use this idea to decompose $M$ and construct
a partial order on the components similarly. The resulting structural
observations are used to come up with the required algorithm for tree
path assignment. 

A prime sub-matrix of $M$ is defined as the matrix formed by a set of
columns of $M$ which correspond to a connected component of the graph
$G_f$.  Let us denote the prime sub-matrices by $M_1,\ldots,M_p$ each
corresponding to one of the $p$ components of $G_f$. Clearly, two
distinct matrices have a distinct set of columns.  Let $col(M_i)$ be
the set of columns in the sub-matrix $M_i$.  The support of a prime
sub-matrix $M_i$ is defined as $supp(M_i) = \displaystyle \bigcup_{j
  \in col(M_i)}S_j$.  Note that for each $i$, $supp(M_i) \subseteq U$.
For a set of prime sub-matrices $X$ we define
$supp(X) = \displaystyle \bigcup_{M \in X} supp(M)$. \\


\noindent
Consider the relation $\preccurlyeq$ on the prime sub-matrices $M_1,
\ldots, M_p$ defined as follows:
\begin{equation} 
\nonumber \{(M_i,M_j) | \mbox{ A set } S \in
  M_i \mbox{ is contained in a set } S' \in M_j\} \cup \{(M_i,M_i) | 1
  \leq i \leq p\} 
\end{equation}

\noindent
This relation is the same as that defined in \cite{nsnrs09}. The prime
submatrices and the above relation can be defined for any set
system. We will use this structure of prime submatrices to present our
results on an an ICPPA for a set system $\cF$. Recall the following
lemmas, and theorem that $\preccurlyeq$ is a partial order, from
\cite{nsnrs09}.

\begin{lemma} \label{lem:containment}
Let $(M_i,M_j) \in \preccurlyeq$.  Then there is a set $S' \in M_j$ such that for each $S \in M_i$, $S \subseteq S'$. 
\end{lemma}
\begin{lemma}
For each pair of prime sub-matrices, either $(M_i,M_j) \not\in \preccurlyeq$ or $(M_j,M_i) \not\in \preccurlyeq$.
%If $(M_i,M_j) \in \preccurlyeq$ and $(M_j,M_i) \in \preccurlyeq$, then $i = j$ and $|M_i| = 1$.
\end{lemma}
\begin{lemma}
If $(M_i,M_j) \in \preccurlyeq $ and $(M_j,M_k) \in \preccurlyeq$, then $(M_i,M_k) \in \preccurlyeq$.
\end{lemma}
\begin{lemma} \label{lem:twoparents}
If $(M_i,M_j) \in \preccurlyeq$ and $(M_i,M_k) \in \preccurlyeq$, then
either $(M_j,M_k) \in \preccurlyeq$ or $(M_k,M_j) \in \preccurlyeq$. 
\end{lemma}
\begin{theorem} \label{thm:partitionold}
  $\preccurlyeq$ is a partial order on the set of prime sub-matrices
  of $M$.  Further, it uniquely partitions the prime sub-matrices of
  $M$ such that on each set in the partition $\preccurlyeq$ induces a
  total order.
\end{theorem}
For the purposes of this paper, we refine the total order mentioned in
Theorem \ref{thm:partitionold}. We do this by identifying an in-tree
rooted at each maximal upper bound under $\preccurlyeq$.  Each of
these in-trees will be on disjoint vertex sets, which in this case
would be disjoint sets of prime-submatrices.  The in-trees are
specified by selecting the appropriate edges from the Hasse diagram
associated with $\preccurlyeq$.  Let $\cI$ be the following set:
\begin{align*}
  \cI = \{ (M_i,M_j) \in \preccurlyeq \mid \nexists M_k s.t. M_i \preccurlyeq M_k, M_k \preccurlyeq M_j
  \} \cup \{ (M_i,M_i), i \in [p] \}
\end{align*}

\begin{theorem} \label{thm:partition} Consider the directed graph $X$
  whose vertices correspond to the prime sub-matrices, and the edges
  are given by $\cI$.  Then, $X$ is a vertex disjoint collection of
  in-trees and the root of each in-tree is a maximal upper bound in
  $\preccurlyeq$.
\end{theorem}
\begin{proof}
To observe that $X$ is a collection of in-trees, we observe that for         
vertices corresponding to maximal upper bounds, no out-going edge is
present in $X$.  Secondly, for each other element, exactly one
out-going edge is chosen (due to lemma \ref{lem:twoparents} and the
condition in set $\cI$ definition), and for the 
minimal lower bound, there is no in-coming edge.  Consequently, $X$ is
acyclic, and since each vertex has at most one edge leaving it, it
follows that $X$ is a collection of in-trees, and for each in-tree,
the root is a maximal upper bound in $\preccurlyeq$.  Hence the
theorem. \qed
\end{proof}
Let the partition of $X$ given by Theorem \ref{thm:partition} be
$\{X_1,\ldots,X_r\}$.  Further, each in-tree itself  
can be layered based on the distance from the root.  The root is
considered to be at level zero. For $j \geq 0$, Let $X_{i,j}$ denote
the set of prime matrices in level $j$ of in-tree $X_i$.   

\begin{lemma}
\label{lem:subicppa}
Let $M$ be a matrix and let $X$ be the directed graph whose vertices
are in correspondence with the prime submatrices of $M$.  Further let
$\{X_1,\ldots,X_r\}$ be the partition of $X$ into in-trees as defined
above. 
Then, matrix $M$ has an ICPPA in tree $T$ iff $T$ can be partitioned
into vertex disjoint subtrees 
 $\{T_1, T_2, \dots T_r\}$ such that, for each $1 \leq i \leq r$, the
 set of prime sub-matrices corresponding to vertices in $X_i$ has an
 ICPPA in $T_i$. 
\end{lemma}
\begin{proof}
Let us consider the reverse direction first.  Let us assume that $T$
can be partitioned into $T_1, \ldots, T_r$ such 
that for each $1 \leq i \leq r $, the set of prime sub-matrices
corresponding to vertices in $X_i$ has an ICPPA in $T_i$.  It is clear
from the properties of the partial order $\preccurlyeq$ that these
ICPPAs naturally yield an ICPPA  of $M$ in $T$.  The main property
used in this inference is that for each $1 \leq i \neq j \leq r$,
$supp(X_i) \cap supp(X_j) = \O$.   

\noindent
To prove the forward direction, we show that if $M$ has an ICPPA, say
$\cA$, in $T$, then there exists 
  a partition of $T$ into vertex disjoint subtree $T_1, \ldots, T_r$
  such that for each $1 \leq i \leq r$, the set of prime sub-matrices
  corresponding to vertices in $X_i$ has an ICPPA in $T_i$.  For each
  $1 \leq i \leq r$, we define based on $\cA$ a subtree  
$T_i$ corresponding to $X_i$.  We then argue that the trees thus
defined are vertex disjoint, and complete the proof. 
 Consider $X_i$ and consider the prime sub-matrix in $X_{i,0}$.
 Consider the paths assigned under $\cA$ to the sets in the prime
 sub-matrix in $X_{i,0}$.  Since the component in $G_f$ corresponding
 to this matrix is a connected component, it follows that union of
 paths assigned to this prime-submatrix is a subtree of $T$.  We call
 this sub-tree $T_i$.  All other prime-submatrices in $X_i$ are
 assigned paths in $T_i$ since $\cA$ is an ICPPA, and the support of
 other prime sub-matrices in $X_i$ are contained in the support of the
 matrix in $X_{i,0}$.  Secondly, for each $1 \leq i \neq j \leq r$,
 $supp(X_i) \cap supp(X_j) = \O$, and since $\cA$ is an ICPPA, it
 follows that $T_i$ and $T_j$ are vertex disjoint.  Finally, since
 $|U| = |V(T)|$, it follows that $T_1, \ldots, T_r$ is a partition of
 $T$ into vertex disjoint sub-trees such that for each $1 \leq i \leq
 r$, the set of matrices corresponding to nodes in $X_i$ has an ICPPA
 in $T_i$.  Hence the lemma. \qed
\end{proof}
 The essence of the following lemma is that an ICPPA only needs to be
 assigned to the prime sub-matrix corresponding to the root of each
 in-tree, and all the other prime sub-matrices only need to have an
 Intersection Cardinality Preserving Interval Assignments (ICPIA).
 Recall, an ICPIA is an assignment of intervals to sets such that the
 cardinality of an assigned interval is same as the cardinality of the
 interval, and the cardinality of intersection of any two sets is same
 as the cardinality of the intersection of the corresponding
 intervals.  It is shown in \cite{nsnrs09} that the existence of an
 ICPIA is a necessary and sufficient condition for a matrix to have
 the COP.  
We present the pseudo-code to test if $M$ has an ICPPA in $T$. 
\begin{lemma} \label{lem:rooticppa}
Let $M$ be a matrix and let $X$ be the directed graph whose vertices
are in correspondence with the prime submatrices of $M$.  Further let
$\{X_1,\ldots,X_r\}$ be the partition of $X$ into in-trees as defined
earlier in this section. 
Let $T$ be the given tree and let $\{T_1, \ldots, T_r\}$ be a given
partition of $T$ into vertex disjoint sub-trees. 
Then, for each $1 \leq i \leq r$, the set of matrices corresponding to
vertices of $X_i$ has an ICPPA in $T_i$ if and only if the matrix in
$X_{i,0}$ has an ICPPA in $T_i$ and all other matrices in $X_i$ have
an {\bf {\em ICPIA}}. 
\end{lemma}
\begin{proof}
The proof is based on the following fact- $\preccurlyeq$ is a partial
order and $X$ is a digraph which is the disjoint 
union of in-trees.  Each edge in the in-tree is a containment
relationship among the supports of the corresonding
sub-matrices. Therefore, any ICPPA to a prime sub-matrix that is not
the root is contained in a path assigned to the sets in the parent
matrix.  Consequently, any ICPPA to the prime sub-matrix that is not
at the root is an ICPIA, and any ICPIA can be used to construct an
ICPPA to the matrices corresponding to nodes in $X_i$ provided the
matrix in the root has an ICPPA in $T_i$.   Hence the lemma. \qed
\end{proof}
Lemma \ref{lem:subicppa} and Lemma \ref{lem:rooticppa} point out two
algorithmic challenges in finding an ICPPA for a given set system
$\cF$ in a tree $T$.  Given $\cF$, finding $X$ and its partition
$\{X_1,\ldots,X_r\}$ into in-trees can be done in polynomial time.  On
the other hand, as per lemma \ref{lem:subicppa} we need to parition
$T$ into vertex disjoint sub-trees $\{T_1, \ldots, T_r\}$ such that
for each $i$, the set of matrices corresponding  to nodes in $X_i$
have an ICPPA in $T_i$.  This seems to be a challenging step, and it
must be remarked that this step is easy when $T$ itself is a path, as
each individual $T_i$ would be sub-paths.  The second algorithmic
challenge is identified by lemma \ref{lem:rooticppa} which is to
assign an ICPPA from a given tree to the matrix associated with the
root node of $X_i$. 
  
\begin{algorithm}[h]
\caption{Algorithm to find an ICPPA for a matrix $M$ on tree $T$: $main\_ICPPA(M, T$)}
\label{Al:icppa-main}
\begin{algorithmic}
\STATE Identify the prime sub-matrices. This is done by constructing
the strict overlap graph and identifying the connected components. Each
connected component yields a prime sub-matrix.   \\ 
\STATE Construct the partial order $\preccurlyeq$ on the set of prime
sub-matrices.  \\ 
\STATE Construct the partition $X_1,\ldots,X_r$ of the  prime
sub-matrices induced by $\preccurlyeq$ \\
\STATE For each $1 \leq i \leq r$, Check if all matrices except those
in $X_{i,0}$ has an ICPIA.  If a matrix does not have ICPIA exit with
a negative answer.  To check for the existence of ICPIA, use the
result in \cite{nsnrs09}. 
\label{l:icppasubtree} \STATE  Find a partition of $T_1, \ldots, T_r$ such that matrices in
$X_{i,0}$ has an ICPPA in $T_i$.  If not such 
partition exists, exit with negative answer.  
\end{algorithmic}
\end{algorithm}


\section{Finding tree path labeling from $k$-subdivided stars}

As we saw earlier, the algorithm \ref{Al:icppa-main} for the problem
of tree path labeling to a path system in a general tree is not
polynomial time. Algorithm \ref{Al:icppa-main} line
\ref{l:icppasubtree} leaves an unsolved problem in the main ICPPL
algorithm where ICPPL needs to be found out for the mub of each
partition $X_i$ i.e, $X_{i0}$ on subtree $T_i$. Essentially this is
the problem of finding a path labeling to an overlap component of $\cH_\cF$ from a
subtree of $T$.
When the subtrees are restricted to a smaller class, namely 
$k$-subdivided stars, we have an algorithm which has better time complexity.\\


\noindent
Following the notation in the previous section, the subtree assigned to the partition
$X_i$ is $T_i$. We saw that it is sufficient to find the ICPPL for $X_{i0}$
from $T_i$ to find the ICPPL for the set subsystems corresponding to
the whole partition $X_i$. Hence in this section, we are interested in
the mub $X_{i0}$ of partition $X_i$.  Let the set subsystem
corresponding to $X_{i0}$ be $\cO_{i0}$. For ease of notation and due to our focus here being only on the overlap subsystem
of the mub and the assigned subtree, we will drop the subscripts, and
call $\cO$ and $T$ as the set system and tree (rather than set
subsystem and subtree) respectively.\\ 

\noindent
Note that here we assume the partitioning of the tree $T$
into subtrees $\{T_i \mid T_i \text{ assigned to } X_i, T_i \subseteq T,  1 \le i \le t\}$ has been
done. The problem of partitioning $T$ is a problem that needs to be
addressed separately and is not covered in this paper at the moment.

%%%%%%%%%%%%
%%        %%
\noindent
\rfootnote{could be explored for logspace algo::
{\em Slots} are sets of elements in the universe $supp(\cF)$ which either
appear together in a set or do not appear in a set at all (as defined
in \cite{kklv10}).  \rcomment{mention partative family connection?}
\rcomment{Define ``slot'' in prelim sec}
If $T$ is a three leaved tree, it is clear that there is exactly one vertex $r$ in $T$ that has
degree $d(r) = 3$.\rfootnote{unexplored: Which is the set(s) that
  maps to a path(s) that has $r$?} In \cite{kklv10} they find the two {\em
  side slots} by identifying the two {\em maximum marginal} sets from $\cF$ (or
hyperedge from hypergraph $\cH$ in their set up). \rcomment{define
  ``marginal'', ``side slot'' in prelim or here.} Using this side slot
a partial order is defined that in their case (intervals) totally
orders $supp(\cF)$. From this it is easy to derive the 
the interval isomorphism and labeling.\\

\noindent
Calculate the slots in $supp(\cF)$ and let them be $Y_1, Y_2 ... Y_k$,
$k \in \mathbb{N}$.

\rcomment{Define ``marginal slot'' for a set in the system. How do we
  find it? 
}
\begin{lemma}
  If a set $S \in \cF$ has three marginal slots and if $v$ is the
  unique vertex in a three leaved tree $T$ such that $d(v) = 3$, $S$
  contains the element mapped to $v$ by a feasible tree path labeling
  if one exists. i.e. $\cl^{-1}(v) \in S$ where $\cl$ is a feasible
  tree path labeling. If such a labeling cannot be found, there does
  not exist a feasible tree path labeling for $\cF$ from $T$.
\end{lemma}
\begin{proof}
  \rcomment{TBD}
\end{proof}

\noindent
There will be exactly
three end slots if $\cF$ has a TPL to $T$. For each slot $Y_i, i \in
[k]$, do the following till a solution is found. Assume $Y = Y_i$ is
an end slot. Define the following partial order $\preccurlyeq_Y$ on $supp(\cF)$
\begin{enumerate}
\item if $u \in Y$ and $v \notin Y$ then $u \preccurlyeq_Y v$
\item if $u, v \in S$, where $S \in \cF$, then for every $w \notin S$,
  if $u \preccurlyeq_Y w$ then $v \preccurlyeq_Y w$ or if $w \preccurlyeq_Y u$ then $w \preccurlyeq_Y v$
\end{enumerate}

This is clearly a partial order since it is reflexive, antisymmetric and
transitive 
\rcomment{prove?}.

\begin{theorem}
  Let the Hasse diagram of the partial order $\preccurlyeq_Y$ defined
  above be $H_{\preccurlyeq_Y}$. Then if $T$ is a subgraph of
  $H_{\preccurlyeq_Y}$, there exists a TPL to $\cF$ from $T$.
\end{theorem}
\begin{proof}
 \qed
\end{proof}
}

\rfootnote{tried first/unexplored:
  let slot that gets
assigned to the path with $r$ be $Y_r$. If $T_i$ is rooted at $r$ we
have exactly three paths from $r$ to the three leaves which are vertex
disjoint except at $r$. -- but it is not straightforward to find this
special slot. end slots are easier to find see kklv10.}  
\rfootnote{tried: There will be three marginal sets and three end slots. pick one at
random. Let it be $Y = Y_i, i \in [k]$
Use the partial ordering idea in \cite{kklv10} (page 10 para 1)
$\le_{Y}$. However in this case it will not be a total order. 
Assign paths as in pg 10 eq (3). \\
Finding $Y$ involves something similar to the marginal hyperedge
idea in \cite{kklv10}.}
%%        %%
%%%%%%%%%%%%

\noindent
We generalize the interval assignment algorithm for an overlap
component from a prime matrix in \cite{nsnrs09} (algorithm 4 in their paper) to find
tree path labeling for overlap component $\cO$. The tree $T$ is a
$k$-subdivided star. The vertex $r$ is the center of the star.\\

The outline of the algorithm is as follows. Notice that the path
between a leaf and the center vertex has the property that none of the
vertices except the center has degree greater than 2. Thus each ray excluding the center
can be considered as independent intervals. 
 So we begin by labeling of hyperedges to paths that have vertices
 from a single ray only and the center vertex. Clearly this can be
 done using ICPIA alone. This is done for each ray one
after another till a condition for a blocking hyperedge is reached
for each ray which is described below. This part of the algorithm is called the
{\em initialization of path labeling}. 

When considering labeling from any
particular ray, we will reach a point in the algorithm were we cannot
proceed further with ICPIA alone because the overlap properties of the
hyperedge will require a path that will cross the center of the star
to another ray and ICPIA cannot tell us which ray that would be. Such
a hyperedge is called {\em blocking hyperedge} of that ray. At this
point we make the following observation about the classification of
the hyperedges in $\cO$.
\begin{itemize}
\item[i] {\em Type 0/ labeled hyperedges}: The hyperedges that have been labeled.
\item[ii] {\em Type 1/ unlabeled non-overlapping hyperedges}: The hyperedges that are either contained or
  disjoint from type 0 hyperedges.
\item[iii] {\em Type 2/ unlabeled overlaping hyperedges}: The hyperedges that overlap with at least one
  labeled hyperedge, say $H$, but cannot be labeled to a path in the
  same ray as $\cl(H)$ alone. It requires verices from another ray
  also in its labeling. A {\em blocking hyeredge} is one of this kind
  which is encountered in each iteration of the initialization of rays algorithm.
\end{itemize}

Since $\cO$ is an overlap component, the type 1 hyperedges overlap
with some type 2 hyperedge and can be handled after type 2
hyperedges. Note that in the algorithm outlined above, we find a single
blocking hyperedge and it is a type 2 hyperedge, per ray. Consider a
ray $R_i = \{v \mid v \in V(T), v \text{ is in $i$th ray or is the center}\}$ and its
corresponding blocking hyperedge $B_i$. Now we try
to make a partial path labeling such that for every $i \in [l]$. We partition the blocking
hyperedge into two subsets $B_i = B'_i \cup B''_i$ such that $B'_i,
B''_i$ map to paths $P'_i, P''_i$ respectively which are defined as
follows. 
\begin{table}[h]
  \centering
  \begin{tabular}[h]{ll}
    $P'_i$ &$\subseteq R_i \text{ such that } $$r \in P'_i $\\
&and 
$|P'_i| = k+2- |supp(\{P \mid P \text{ is a path from $R_i$ assigned to type 0
  hyperedges} \})|$\\
$P''_i$ &$\in \{P_{i,j} \mid j \in [l], j \ne i\}$ \\
&$\text{where } P_{i,j} = \{v_{j,p} \mid v_{j,0} \text{ is adjacent
  to $r$ on $R_j$, }$\\
&for all $ 0 < p \le |B_i \setminus P'_i|-1,
v_{j,p} \text{ is adjacent to } v_{j,p-1}\}$ \\ 
$P'_i \cup P''_i$ & $\text{ is a path in $T$}$
  \end{tabular}
\end{table}

****** DIAGRAM *******
The path $P'_i$ is obvious and the following procedure is used to find
$P''_i$. It is clear that a hyperedge cannot be blocking more than two rays,
since a path cannot have vertices from more than two rays. If the blocking 
hyperedge $B_a$ of ray $R_a$ is also the blocking hyperedge for
another ray $R_b$ (i.e. $B_a = B_b$), then clearly $P''_a = P_{a,b}$
(and $P''_b = P_{b,a}$). If $B_a$ does not block any other rays of the
star other than $R_a$, then we find that it must intersect with
exactly one other blocking hyperedge, say $B_b$. Once we find that
ray,  then clearly $P''_a = P_{a,b}$. Note that $P''_b \ne P_{b,a}$ in
this case else it would have been covered in the previous case.
Now we continue to find new blocking hyperedges on all rays until the
path labeling is complete. 

\noindent
The function $dist(u,v)$ returns the number of vertices between the
vertices $u$ and $v$ on the path between them. 

The algorithm is formally described as follows. Algorithm
\ref{al:icppl-kleaves_symm_starlike__4} is the main algorithm which
uses algorithms \ref{al:icppl-initialize_rays_symm_starlike},
\ref{al:icppl-saturate_rays_symm_starlike} and
\ref{al:icppl-partial_labeling_symm_starlike} as subroutines.


\begin{algorithm}[h]
\caption{Algorithm (main subroutine) to find an ICPPL $\cl$ for an overlap
  component $\cO$ from $k$-subdivided star graph $T$:
  $overlap\_ICPPL\_l\_leaves\_symstarlike3(\cO, T$)} 
\label{al:icppl-kleaves_symm_starlike__4}
%{\tiny
\begin{algorithmic}[1]

\STATE $\cL$  
\COMMENT {$\cL \subseteq \cO$ is a global variable for the set subsystem that has a
  path labeling so far. It is the domain of the feasible path labeling $\cl$ at
  any point in the algorithm.}

\STATE $\cl$ 
\COMMENT {$\cl: \cL \rightarrow \cP$, is a global
  variable representing a feasible path
  labeling of $\cL$ to some path system $\cP$ of $T$. It is
  the partial feasible path labeling of $\cO$ at any point in the algorithm.}

%\STATE $i \leftarrow initialize\_rays(\cO, T)$ 
\STATE $initialize\_rays(\cO, T)$ 
\COMMENT {Call algorithm
  \ref{al:icppl-initialize_rays_symm_starlike} for initialization of rays.
  This is when a hyperedge is assigned to a path with the ray's
  leaf.} % $i$ rays are initialized.}

\WHILE {$\cL \ne \cO$}
  \STATE $saturate\_rays\_and\_find\_blocking\_hyperedges(\cO, T)$
  \COMMENT {Saturate all rays of $T$ by using algorithm 
  \ref{al:icppl-saturate_rays_symm_starlike}. This subroutine also
  finds the blocking hyperedge $\cB_i$ of each ray $i$. A blocking
  hyperedge is one that needs to be labeled to a path that has
  vertices from exactly two rays.}

  \STATE $partial\_path\_labeling\_of\_blocking\_hyperedges(\cO, T)$
  \COMMENT {Find path labeling of blocking hyperedges by using
    algorithm \ref{al:icppl-partial_labeling_symm_starlike}. This subroutine
  finds the part of the blocked hyperedge's path label that comes from the second ray.}

\ENDWHILE % \cL \ne \cO

\end{algorithmic} %}
\end{algorithm}


\begin{algorithm}[h]
\caption{$initialize\_rays(\cO, T)$}
\label{al:icppl-initialize_rays_symm_starlike}
%{\tiny
\begin{algorithmic}[1]

\STATE Let $\{ v_i
\mid i \in [l], l \text{ is number of leaves of $T$} \}$ 
\COMMENT {Also note $k+2$ is the length of the path from the center to
  any leaf since $T$ is $k$-subdivided star.}

\STATE $\cK  \leftarrow \{ H \mid H \in \cO$, $N(H)$ in $\cO$ is a
clique $\}$ \COMMENT {Local variable to hold the marginal
  hyperedges. A marginal hyperedge is one that has exactly one
  inclusion chain of interections with every set it overlaps with,
  i.e., its neighbours in the overlap graph form a clique.}

% \STATE $\cK  \leftarrow \{ H \mid H \in \cO$ s.t. neighbours of $H$ in
% the overlap graph form a clique$\}$ 
\FOR {every inclusion chain $C \subseteq \cK$ }
  \STATE Remove from $\cK$ all sets in $C$ except the set
  $H_{C-icpia-max}$ which is the set closest to the maximal inclusion set $H_{C-max}$
  such that $|H_{C-icpia-max}| \le k+2$. 
\ENDFOR % every inclusion chain $C \subseteq \cK$ 

\IF {$|\cK| > l$}
  \STATE Exit. %%%%%%%%%%******** NEEDS PROOF
  \COMMENT {No labeling possible since $\cO$ is an overlap component and
  $T$ does not have enough rays.}
\ENDIF

%\IF {$|\cK| < l$}
\label{line:Li_is_empty}  
\STATE \COMMENT { $H_{C-icpia-max}$ does not exist for at least one ray. Labeling
  could still be possible because $H_{C-max}$ could be a viable blocking
  hyperedge itself. Hence proceed.}
%\ENDIF

\STATE $i \leftarrow 0$
\FOR {every hyperedge $H \in \cK$}
  \STATE $i \leftarrow i+1$
  \STATE $\cl(H) \leftarrow P_i$ where $P_i$ is the path in $T$
  containing leaf $v_i$ such that $|P_i| = |H|$.
  \STATE $\cL \leftarrow \cL \cup \{H\}$
\ENDFOR % every $H \in \cK$
\STATE Return the number of initialized rays, $i$.
\end{algorithmic} %}
\end{algorithm}



\begin{algorithm}[h]
\caption{$saturate\_rays\_and\_find\_blocking\_hyperedge(\cO, T)$}
\label{al:icppl-saturate_rays_symm_starlike}
%{\tiny
\begin{algorithmic}[1]
 
\STATE Variable $\cB_i$ shall store the blocking hyperedge for $i$th ray. Init
variables: for every $i \in [l]$, $\cB_i \leftarrow \O$
\STATE Let $\cL_i \subseteq \cL$ containing hyperedges labeled to $i$th ray i.e. $\cL_i = \{H \mid
\cl(H) \subseteq R_i\}$

\FOR {every $i \in [l]$} 
\STATE \COMMENT {for each ray}
  \IF {$L_i = \O$} 
  \STATE \COMMENT {Due to the condition \ref{line:Li_is_empty} in algorithm
  \ref{al:icppl-initialize_rays_symm_starlike}}
    \STATE $\cK  \leftarrow \{ H \mid H \in \cO \setminus \cL$ s.t. neighbours of
    $H$ in the overlap graph of $\cO$ form a clique$\}$ 
    \STATE Pick an inclusion chain $C \subseteq \cK$ and let
    $H_{C-max}$ be the maximal inclusion hyperedge in $C$.
    \STATE $\cB_i \leftarrow H_{C-max}$ \COMMENT {Since $H_{C-max} \in
    \cL$, and due to earlier subroutines, $|H_{C-max}| > k+2 $}
  \ENDIF % $L_i = \O$

  \WHILE {$\cB_i = \O$ and there exists $H \in \cO \setminus \cL$, such that $H$ overlaps with some
    hyperedge $H' \in \cL_i$} 
    \STATE $d \leftarrow |H \setminus H'|$ 
    \STATE Let $u$ be the end vertex of the path $\cl(H')$ that is
    closer to the center $r$, than its other end vertex 

    \IF {$d \le dist(u, r)+1$} 
      \STATE Use ICPIA to assign path $P \subseteq R_i$ to $H$ 
      \STATE $\cl(H) \leftarrow P$ \COMMENT {Update variables}
      \STATE $\cL \leftarrow \cL \cup \{H\}$, $\cL_i \leftarrow \cL_i \cup \{H\}$
   \ELSE
      \STATE $\cB_i \leftarrow H$
      \STATE Continue \COMMENT{Found the blocking hyperedge for this ray; move on to
      next ray}
    \ENDIF    
  \ENDWHILE % $\cB_i = \O$
\ENDFOR

\end{algorithmic} %}
\end{algorithm}


\begin{algorithm}[h]
\caption{$partial\_path\_labeling\_of\_blocking\_hyperedges(\cO, T)$}
\label{al:icppl-partial_labeling_symm_starlike}
%{\tiny
\begin{algorithmic}[1]

\STATE \COMMENT {Process equal blocking hyperedges. At this point for
  all $i \in [l]$, $\cB_i \ne \O$.} 
\FOR {every $i \in [l], \cB_i \ne \O$}
  \FOR {every $j \in [l]$}
    \IF {$\cB_i = \cB_j$}
      \STATE \COMMENT {Blocking hyperedges of $i$th and $j$th rays are same}
      \STATE Let $H \leftarrow \cB_i$ \COMMENT { or $\cB_j$ }
      \STATE Find path $P$ on the path $R_i \cup R_j$ to assign to
      $H$ using ICPIA
      \STATE $\cl(H) \leftarrow P$
      \STATE $\cL \leftarrow \cL \cup \{H\}$
      \STATE $\cB_i \leftarrow \O$, $\cB_j \leftarrow \O$ \COMMENT
      {Reset blocking hyperedges for $i$th and $j$th rays}
    \ENDIF
  \ENDFOR % j > i
\ENDFOR % i

\STATE \COMMENT {Process intersecting blocking hyperedges}
\FOR {every $i \in [l], \cB_i \ne \O$}
  \FOR {every $j \in [l]$}
    \IF {$\cB_i \cap (supp(\cL_j \cup
    \cB_j)) \ne \O$}
      \STATE \COMMENT {Blocking hyperedge of $i$th ray intersects with hyperedge
    associated with $j$th ray}
      \STATE Find interval $P_i$ for $\cB_i$, on the path $R_i \cup R_j$ that
      satisfies ICPIA. 
      \STATE $\cl(\cB_i) \leftarrow P_i$
      \STATE $\cB_i \leftarrow \O$
      \STATE $\cL \leftarrow \cL \cup \{\cB_i\}$
    \ENDIF
  \ENDFOR % j
\ENDFOR % i

\end{algorithmic} %}
\end{algorithm}






%\section {Acknowlegements:} 
%TBD

%\bibliographystyle{plainnat}
\bibliographystyle{alpha} %to have only [i] type of citation
\bibliography{../lib/cop-variants}


\pagebreak
\appendix

\section{Detailed proofs}

\noindent
\begin{proof}[Lemma \ref{lem:invar1}]
  \noindent
  \begin{enumerate}
  \item [Case 1:] {\em Invariant I and II} 
    \begin{enumerate}
    \item [Case 1.2:] {\em $R$ is a new set:}\\ 
      If $R = S_1 \cap S_2$, $|R| = |S_1 \cap S_2| = |\cl_{j-1}(S_1) \cap
      \cl_{j-1}(S_2)|\footnote{Inv III hypothesis} = |\cl_j(S_1 \cap
      S_2)|\footnote{$\cl_j$ definition} = |\cl_j(R)|$\\
      If $R = S_1 \setminus S_2$, 
         $|R| = |S_1 \setminus S_2| 
              = |S_1| - |S_1 \cap S_2| 
              = |\cl_{j-1}(S_1)| - |\cl_{j-1}(S_1) \cap \cl_{j-1}(S_2)|\footnote{Inv II and III hypothesis} 
              = |\cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)| 
              = |\cl_j(S_1 \setminus S_2)|\footnote{$\cl_j$ definition}
              = |\cl_j(R)|$. \\
      Thus Invariant II proven.
   \end{enumerate}
  \item [Case 2:] {\em Invariant III}
    \begin{enumerate}
    \item [Case 2.2:] {\em Only $R$ is a new set:}\\
      If $R = S_1 \cap S_2$, $|R \cap R'| = |S_1 \cap S_2 \cap R'| = |\cl_{j-1}(S_1) \cap
      \cl_{j-1}(S_2) \cap \cl_{j-1}(R')|\footnote{Inv IV hypothesis} = |\cl_j(S_1 \cap
      S_2) \cap \cl_j(R')|\footnote{$\cl_j$ definition. Note that $R'$ is not a
        new set} = |\cl_j(R) \cap \cl_j(R')|$\\
      If $R = S_1 \setminus S_2$, 
         $|R \cap R'| = |(S_1 \setminus S_2) \cap R'| 
                      = |(\cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2))
                      \cap \cl_{j-1}(R')|\footnote{Lemma \ref{lem:setminuscard}}
                      = |\cl_{j}(R) \cap \cl_{j}(R')|\footnote{$\cl_j$
                        definition. Note $R'$ is not a new set}$\\
      Thus Invariant III proven.
    \end{enumerate}
  \end{enumerate}
\end{proof}

\end{document}



\section{Certifying algorithm for tree path labeling to a set system}
\begin{enumerate}
\item[1.] {\em incompatibility relation is the ICPIA relation. each vertex
  is ordered pair (set,interval) s.t. card(set) = card(interval). for all vertices having
  the same set in its label form a clique since the ICPIA condition
  does not hold. If two vertices $(S_1, \cl(S_1))(S_2,\cl(S_2))$, where
  $\cl: \cF \rightarrow \cI$ is {\em { one of the possible interval
      labelings}} of $\cF$, are such that
%******************** !!!
  pairwise intersections are not preserved, then they have an edge
  between them else not. if there is no independent set of size $n$
  then there is no ICPIA possible. CONJECTURE: this incompatibility
  graph is a perfect graph.} *** FILL IN FORMAL
DETAILS IN KKLV NOTATION ***\\
CHECK BERGE'S THEOREM. robertson n seymour proved it for perfect graphs.
\item[2.] {\em incompatibility graph for tree labeling to set
    system. extending the idea above we create an incompatibility
    3-uniform hypergraph. vertices are ordered pairs (set,tree path) with
    cardinalities preserved. a hyperedge involving three vertices is present iff the three
    vertices involved have three way intersection cardinalities
    preserved. there does not exist an independent set of size $n$
    in this graph iff there cannot be a tree path labeling to the
    given set system} *** FILL IN FORMAL DETAILS IN KKLV NOTATION
  ***
\item[3.] {\em incompatibilty graph as in [2] but without using
    hypergraphs. edges represent incompatible pairwise intersections
    as in [1]. three way intersections are not represented (it could
    be we need to come up with that). how can we find an independent
    set such that the ICPPL condition is met? }
\item [4.] {\em can we extend the side slot idea to trees and how? if
    so, what kind of ordering can we use? any two of preorder,
    inorder, postorder defines the tree uniquely. this could be used
    to define a partial order based on ``side slots''.} *** FILL IN FORMAL DETAILS IN KKLV NOTATION
  ***\\
- definition of slots is general for any set system. therefore remains
same here.\\
- ``side slots'' can be the slots that have the root? must have a
concept equivalent of ``maximal side slot'' ---- no, before that we
need to decide what should the ordering be. how do we use it to define
the partial order. then characterize the maximal special slot.
\end{enumerate}



\section{ICPPL from 3 leaved tree/k leaved symmetric tree }
\label{para:3-leaved}
$T$ is three leaved tree which is not necessarily symmetric -
Unverified/incomplete Algorithm \ref{al:icppl-3leaves__1}.\\

\noindent
$T$ is $k$ leaved and symmetric. Starting from one arbitrary arm and
trying other arms after reaching center of graph - Unverified/incomplete Algorithm \ref{al:icppl-kleaves_symm_starlike__2}.\\

\begin{algorithm}[h]
\caption{Algorithm to find an ICPPL $\cl$ for an overlap component $\cO$ from tree $T$: $overlap\_ICPPL\_3\_leaves(\cO, T$)}
\label{al:icppl-3leaves__1}
%{\tiny
\begin{algorithmic}[5]
\STATE Find $H_0 \in \cO$ s.t. all the sets that intersect with $H_0$
 have non-empty pairwise intersections with each other. \\
\STATE $\cL \leftarrow \{ H_0 \}$, $\cl \leftarrow \O$  %// list of hyperedges given path labels
%\STATE \\         %// resetting path label function
\STATE Choose a path $P_0$ from $T$ containing leaf $v_1$ s.t. $|H_0|=|P_0|$\\
\STATE Assign $\cl(H_0) \leftarrow P_0$, $\cX \leftarrow \O$\\ %// set of tested paths for H defined below
\STATE Push $(H_0, v_1)$ to stack\\     %// for backtracking
\WHILE {there exists $H \in \cO \setminus \cL$, such that $H$ intersects with some set in $\cL$, say $H'$}
\WHILE {there exists a path $P$ from $T$ s.t. $P \notin \cX$ and $|P \cap \cl(H')| = |H \cap H'|$}

  \IF {$\cl(H')$ has $r$}
    \STATE there will be two paths containing r $P_{r1}, P_{r2}$, one each containing the
    end points $P_{1}, P_{2}$.\\
    \STATE add to $\cL$, assign $\cl$, push to stack appropriately after
    checking ICPPL conditions.\\
    \STATE if all of them fail ICPPL, backtrack. Else continue.\\
  \ENDIF

  \STATE $d \leftarrow |H' \setminus H|$ \\
  \STATE Let $u_1, u_2$ be the end vertices of $\cl(H')$\\
 \IF {$d \le dist(u_1, r)$ and $d \le dist(u_2, r)$} 
  %only one possibile RIGHT path. two paths to consider.
    \STATE Let $P_1 \leftarrow $ path containing $u_1$ s.t. $|P_1 \cap
     \cl(H')| = |H \cap H'|$\\
    \STATE Let $P_2 \leftarrow $ path containing $u_2$ s.t. $|P_2 \cap
     \cl(H')| = |H \cap H'|$\\
    \IF {$(\cL \cup H$, $\cl \cup (H, P_1))$ is an ICPPL}
      \STATE $\cL \leftarrow \cL \cup H$\\
      \STATE $\cl(H) \leftarrow P_1$\\
      \STATE      Push $(H,null)$ to stack\\
    \ENDIF
    \IF {$(\cL \cup H$, $\cl \cup (H, P_2))$ is an ICPPL}
      \STATE $\cL \leftarrow \cL \cup H$\\
      \STATE $\cl(H) \leftarrow P_2$\\
      \STATE      Push $(H,null)$ to stack\\
    \ELSE
      \STATE backtrack.
    \ENDIF
  \ELSE % i.e. $d > dist(u_1, r)$ or $d > dist(u_2, r)$  
    \STATE \textsl{i.e. $d > dist(u_1, r)$ or $d > dist(u_2, r)$}
    %only TWO possibile RIGHT path that can be decided at this iteration.. three paths to consider.
    \STATE Let $P_1 \leftarrow $ path containing $u_1$ s.t. $|P_1 \cap
    \cl(H')| = |H \cap H'|$\\
    \STATE Let $P_2 \leftarrow $ path containing $u_2$ s.t. $|P_2 \cap
    \cl(H')| = |H \cap H'|$\\
    \STATE Let $P_3 \leftarrow $ path containing $u_1$ or $u_2$ and $r$ s.t. $|P_3 \cap
    \cl(H')| = |H \cap H'|$. This would intersect with $P_1$ or $P_2$
    depending on which endpoint is contained in it.\\

    \IF {$(\cL \cup H$, $\cl \cup (H, P_1))$ is an ICPPL}
      \STATE $P \leftarrow P_1$\\
   \ENDIF
    \IF {$(\cL \cup H$, $\cl \cup (H, P_2))$ is an ICPPL}
      \STATE $P \leftarrow P_2$\\
    \ENDIF
    \IF {$(\cL \cup H$, $\cl \cup (H, P_3))$ is an ICPPL}
      \STATE $P \leftarrow P_3$\\
   \ELSE
      \STATE Exit.
    \ENDIF
    \STATE $\cL \leftarrow \cL \cup H$\\
    \STATE $\cl(H) \leftarrow P$\\
    \IF {there is $r \in P$}
      \STATE      Push $(H,r)$ to stack\\
    \ELSE
      \STATE      Push $(H,null)$ to stack\\
    \ENDIF
    \STATE      Break while. Path label for $H$ has been assigned.\\
    \ENDIF % % i.e. $d >/<= dist(u_1, r)$or/and $d >/<= dist(u_2, r)$  
\ENDWHILE % checked all paths

    \IF {all paths in $\cX$ failed}  % backtrack
      \STATE    $(H_x, v_x) \leftarrow $ Pop stack\\
      \WHILE {$v_x = null$}
        \STATE      $\cL \leftarrow \cL \setminus \{ H_x \}$\\
        \STATE      $\cl(H_x) \leftarrow undefined$\\     % // exclude
                                % H_x from \cl domain
      \ENDWHILE
      \IF {$v_x = r$}
        \STATE FIND AN ALTERNATE PATH FOR $H_x$ - LOOK AT POSSIBILITIES AT
        ROOT. REASSIGN $l(H_x)$, PUSH BACK INTO STACK AND CONTINUE WHILE.\\
      \ENDIF
      \IF {$v_x = v_1$}
        \STATE FAILURE AT LEAF. START WITH ANOTHER LEAF. PUT OUTERLOOP
        AND DO A CONTINUE ON THAT.\\
      \ENDIF
    \ENDIF
\ENDWHILE
\end{algorithmic} %}
\end{algorithm}

\begin{algorithm}[h]
\caption{Algorithm to find an ICPPL $\cl$ for an overlap component $\cO$ from tree $T$: $overlap\_ICPPL\_k\_leaves\_symstarlike2(\cO, T$)}
\label{al:icppl-kleaves_symm_starlike__2}
\begin{algorithmic}[1]

\STATE Let $k$ be the length of the path to a leaf from the center.\\
\STATE $\H_l \leftarrow \{ H \mid H \in \cO$ s.t. all the sets that intersect with $H$
 have non-empty pairwise intersections with each other and any set in
 $\H_l$ is not contained in another set in $\H_l$. When there are
 ambiguities regarding containment, choose the largest set whose size
 is less than or equal to $k$ $\}$ \\ % so that it gets assigned only
                                % till the center
\IF {$|\H_l| \ne l$, where $l$ is the number of leaves in $T$}
  \STATE No labeling possible. Exit.
\ENDIF

\STATE For every $i \in [l]$, $\cl(H_i) \leftarrow P_i$ where $H_i \in
\H_l$, $P_i$ is a path in $T$ containing leaf $v_i$ such that $|P_i| =
|H_i|$.
\STATE $\cL \leftarrow \H_l$ % assigned sets


\WHILE {there exists $H \in \cO \setminus \cL$, such that $H$ intersects with some set in $\cL$, say $H'$}

  \STATE $d \leftarrow |H' \setminus H|$ \\
  \STATE Let $u_1, u_2$ be the end vertices of the path $\cl(H')$\\
  \IF [where $r$ is the center of star $T$] {$d \le dist(u_1, r)$ and $d \le dist(u_2, r)$} 
    \STATE Use ICPIA to assign path to $H$ \rcomment{expand}
  \ENDIF
\ENDWHILE

\end{algorithmic}
\end{algorithm}



\section{Complexity of Tree Path Assignment-A Discussion} \label{complexity}
Recall that the input to the Tree Path Assignment question is an order
pair $(\cF,T)$ where $\cF$ is a family of subsets of an universe $U$,
and $T$ is a tree such that $|V(T)| = |U|$.  The question is to come
up with a bijection from 
$U$ to $V(T)$ such that the image of each set in $\cF$ is a path in
$T$.  We show that this problem is at least as hard as the problem of
testing if two given path graphs are isomorphic.   
\begin{theorem} \label{thm:isocomp}
Tree Path Assignment is isomorphism-complete.
\end{theorem}
\begin{proof}
  It is well known (see for example \cite{kklv10}) that testing
  isomorphism of path graphs is isomorphism complete.  We show
  a reduction of path graph isomorphism to tree path
  assignment.  Given $G_1$ and $G_2$ two path graphs, let
  $T_2$ be the clique tree of $G_2$ obtained from say \cite{gav78}.
  The nodes of $T_2$ correspond to the maximal cliques of $G_2$ and
  each vertex of $G_2$ corresponds to a path in $G_2$.  This is a
  well-known characterization of path graphs and $T_2$ can be
  computed in polynomial time.  In $G_1$, let $S_v$ denote the maximal
  cliques of $G_1$ that contain $v$.  This can be computed in
  polynomial time as $G_1$ is a path graph, and all chordal graph only
  have a linear number of maximal cliques.  The universe $U$
  corresponds bijectively to the set of maximal cliques in $G_1$, and
  $\cF = \{S_v | v \in V(G_1)\}$.  Now, we claim that $(\cF, T_2)$ has
  a tree path assignment if and only if $G_1$ and $G_2$ are
  isomorphic.  This is clear since for each vertex $v \in G_1$, there
  is an associated $S_v$ which is the set of maximal cliques
  containing $v$.  In $G_2$, each vertex corresponds to a path in
  $T_2$, and the nodes on this path corresponds to the maximal cliques
  in $G_2$.  Consequently, a tree path assignment will naturally yield
  an isomorphism between $G_1$ and $G_2$, and vice versa.  Therefore,
  Tree Path Assignment is isomorphism-complete. \qed
\end{proof}
\subsection{Consecutive Ones Testing is in Logspace}
While Tree Path Assignment is isomorphism-complete, it is polynomial
time solvable when the given tree is a path.  Indeed, in this case we
encounter a restatement of matrices with the COP.  The known
approaches to testing for COP fall into two categories: those that
provide a witness when the input matrix does not have the COP, and those
that do not provide a witness.  The first linear time algorithm for
testing COP for a binary matrix was using a data structure called PQ
trees, which represent all COP orderings of $M$, invented by
\cite{bl76}. There is a PQ tree for a matrix iff the matrix has the COP.
Indeed, this is an algorithmic characterization of the consecutive
ones property and the absence of the PQ-tree does not yield any
witness to the reason for failure.  A closely related data structure
is the generalized PQ tree in \cite{mcc04}.  In generalized PQ tree
the P and Q nodes are called prime and linear nodes. Aside from that,
it has a third type of node called degenerate nodes which is present
only if the set system does not have the COP \cite{mcc04}.  Using the idea
of generalized PQ tree, \cite{mcc04} proves that checking for
bipartiteness in the certain incomparability graph is sufficient to
check for COP.  \cite{mcc04} invented a certificate to confirm when a
binary matrix does not have the COP.  \cite{mcc04} describes a graph
called incompatibility graph of a set system $\cF$ which has vertices
$(a,b), a \ne b$ for every $a, b \in U$, $U$ being the universe of the
set system. There are edges $((a,b),(b,c))$ and $((b,a),(c,b))$ if
there is a set $S \in \cF$ such that $a, c \in S$ and $b \notin S$. In
other words the vertices of an edge in this graph represents two
orderings that cannot occur in a consecutive ones ordering of $\cF$.
\begin{theorem}[Theorem 6.1, \cite{mcc04}]
  Let $\cF$ be an arbitrary set family on domain $V$. Then $\cF$ has
  the consecutive ones property if and only if its incompatibility
  graph is bipartite, and if it does not have the consecutive ones
  property, the incompatibility graph has an odd cycle of length at
  most $n+3$.
\end{theorem}
This theorem gives a certificate as to why a given matrix does not
have the COP.  Similarly, the approach of testing for an ICPIA in
\cite{nsnrs09} also gives a different certificate- a prime sub-matrix
that does not have an ICPIA.  Further, the above theorem can be used
to check if a given matrix has the COP in logspace by checking if its
incompatibility graph is bipartite. \cite{rei84} showed that checking
for bipartiteness can be done in logspace. Thus we conclude that
consecutive ones testing can be done in logspace.

\noindent
More recently, \cite{kklv10} showed that interval graph isomorphism
can be done in logspace. Their paper proves that a canon for interval
graphs can be calculated in logspace using an interval hypergraph
representation of the interval graph with each hyperedge being a set
to which an interval shall be assigned by the canonization
algorithm. An overlap graph (subgraph of intersection graph, edges
define only strict intersections and no containment) of the hyperedges
of the hypergraph is created and canons are computed for each overlap
component. The overlap components define a tree like relation due to
the fact that two overlap components are such that either all the
hyperedges of one is disjoint from all in the other, or all of them
are contained in one hyperedge in the other. This is similar to the
containment tree defined in \cite{nsnrs09} and in this paper. Finally
the canon for the whole graph is created using logspace tree
canonization algorithm from \cite{sl92}. The interval labelling done
in this process of canonization is exactly the same as the problem of
assigning feasible intervals to a set system, and thus the problem of
finding a COP ordering in a binary matrix \cite{nsnrs09}.

\begin{theorem}[Theorem 4.7, \cite{kklv10}] 
\label{th:canonlabel}
Given an interval hypergraph $\cH$, a canonical interval labeling $l_H$ 
for $H$ can be computed in FL.
\end{theorem}


We present the following reduction to see that COP testing is
indeed in logspace. Given a binary matrix $M$ of order $n \times m$,
let $S_i = \{j \mid M[j,i]=1 \}$. Let $\cF = \{S_i \mid i \in [m] \}$
be this set system. Construct a hypergraph $\cH$ with its vertex set
being $\{1, 2, \dots n\}$. The edge set of $\cH$ is isomorphic to
$\cF$. Thus every edge in $\cH$ represents a set in the given set
system $\cF$. Let this mapping be $\pi: E(\cH) \rightarrow \cF$. It is
easy to see that if $M$ has the COP, then $\cH$ is an interval
hypergraph. From theorem \ref{th:canonlabel}, it is clear that the
interval labeling $l_{\cH}: V(\cH) \rightarrow [n]$ can be calculated
in logspace. Construct sets $I_i = \{ \l_{\cH}(x) \mid x \in E, E \in
E(\cH), \pi(E) = S_i\}$, for all $i \in [m]$. Since $\cH$ is an
interval hypergraph, $I_i$ is an interval for all $i \in [m]$, and is
the interval assigned to $S_i$ if $M$ has the COP.

Now we have the following corollary.
\begin{corollary}
\label{cor:coplog}
  If a binary matrix $M$ has the COP then the interval assignments to each
  of its columns can be calculated in FL.
\end{corollary}

\noindent
Finally, we conclude by asking about the complexity of Tree Path
Assignment restricted to other subclasses of trees.  In particular, is
Tree Path Assignment in caterpillars easier than Tree Path assignment
in general trees.







